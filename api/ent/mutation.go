// Code generated by ent, DO NOT EDIT.

package ent

import (
	"api/ent/machine"
	"api/ent/machineaccessories"
	"api/ent/machinespecification"
	"api/ent/predicate"
	"api/ent/session"
	"api/ent/user"
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeMachine              = "Machine"
	TypeMachineAccessories   = "MachineAccessories"
	TypeMachineSpecification = "MachineSpecification"
	TypeSession              = "Session"
	TypeUser                 = "User"
)

// MachineMutation represents an operation that mutates the Machine nodes in the graph.
type MachineMutation struct {
	config
	op                          Op
	typ                         string
	id                          *int
	name                        *string
	year                        *uint
	addyear                     *int
	liftHeight                  *uint
	addliftHeight               *int
	motorHours                  *uint
	addmotorHours               *int
	drive                       *string
	weight                      *uint
	addweight                   *int
	loadCapacity                *uint
	addloadCapacity             *int
	rentPrice                   *uint
	addrentPrice                *int
	salePrice                   *uint
	addsalePrice                *int
	description                 *string
	hidden                      *bool
	deleted                     *bool
	numberOfImages              *int
	addnumberOfImages           *int
	internalDescription         *string
	clearedFields               map[string]struct{}
	machineSpecification        map[int]struct{}
	removedmachineSpecification map[int]struct{}
	clearedmachineSpecification bool
	machineAccessories          map[int]struct{}
	removedmachineAccessories   map[int]struct{}
	clearedmachineAccessories   bool
	done                        bool
	oldValue                    func(context.Context) (*Machine, error)
	predicates                  []predicate.Machine
}

var _ ent.Mutation = (*MachineMutation)(nil)

// machineOption allows management of the mutation configuration using functional options.
type machineOption func(*MachineMutation)

// newMachineMutation creates new mutation for the Machine entity.
func newMachineMutation(c config, op Op, opts ...machineOption) *MachineMutation {
	m := &MachineMutation{
		config:        c,
		op:            op,
		typ:           TypeMachine,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMachineID sets the ID field of the mutation.
func withMachineID(id int) machineOption {
	return func(m *MachineMutation) {
		var (
			err   error
			once  sync.Once
			value *Machine
		)
		m.oldValue = func(ctx context.Context) (*Machine, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Machine.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMachine sets the old Machine of the mutation.
func withMachine(node *Machine) machineOption {
	return func(m *MachineMutation) {
		m.oldValue = func(context.Context) (*Machine, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MachineMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MachineMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MachineMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MachineMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Machine.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *MachineMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *MachineMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Machine entity.
// If the Machine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MachineMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *MachineMutation) ResetName() {
	m.name = nil
}

// SetYear sets the "year" field.
func (m *MachineMutation) SetYear(u uint) {
	m.year = &u
	m.addyear = nil
}

// Year returns the value of the "year" field in the mutation.
func (m *MachineMutation) Year() (r uint, exists bool) {
	v := m.year
	if v == nil {
		return
	}
	return *v, true
}

// OldYear returns the old "year" field's value of the Machine entity.
// If the Machine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MachineMutation) OldYear(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldYear is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldYear requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldYear: %w", err)
	}
	return oldValue.Year, nil
}

// AddYear adds u to the "year" field.
func (m *MachineMutation) AddYear(u int) {
	if m.addyear != nil {
		*m.addyear += u
	} else {
		m.addyear = &u
	}
}

// AddedYear returns the value that was added to the "year" field in this mutation.
func (m *MachineMutation) AddedYear() (r int, exists bool) {
	v := m.addyear
	if v == nil {
		return
	}
	return *v, true
}

// ResetYear resets all changes to the "year" field.
func (m *MachineMutation) ResetYear() {
	m.year = nil
	m.addyear = nil
}

// SetLiftHeight sets the "liftHeight" field.
func (m *MachineMutation) SetLiftHeight(u uint) {
	m.liftHeight = &u
	m.addliftHeight = nil
}

// LiftHeight returns the value of the "liftHeight" field in the mutation.
func (m *MachineMutation) LiftHeight() (r uint, exists bool) {
	v := m.liftHeight
	if v == nil {
		return
	}
	return *v, true
}

// OldLiftHeight returns the old "liftHeight" field's value of the Machine entity.
// If the Machine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MachineMutation) OldLiftHeight(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLiftHeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLiftHeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLiftHeight: %w", err)
	}
	return oldValue.LiftHeight, nil
}

// AddLiftHeight adds u to the "liftHeight" field.
func (m *MachineMutation) AddLiftHeight(u int) {
	if m.addliftHeight != nil {
		*m.addliftHeight += u
	} else {
		m.addliftHeight = &u
	}
}

// AddedLiftHeight returns the value that was added to the "liftHeight" field in this mutation.
func (m *MachineMutation) AddedLiftHeight() (r int, exists bool) {
	v := m.addliftHeight
	if v == nil {
		return
	}
	return *v, true
}

// ResetLiftHeight resets all changes to the "liftHeight" field.
func (m *MachineMutation) ResetLiftHeight() {
	m.liftHeight = nil
	m.addliftHeight = nil
}

// SetMotorHours sets the "motorHours" field.
func (m *MachineMutation) SetMotorHours(u uint) {
	m.motorHours = &u
	m.addmotorHours = nil
}

// MotorHours returns the value of the "motorHours" field in the mutation.
func (m *MachineMutation) MotorHours() (r uint, exists bool) {
	v := m.motorHours
	if v == nil {
		return
	}
	return *v, true
}

// OldMotorHours returns the old "motorHours" field's value of the Machine entity.
// If the Machine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MachineMutation) OldMotorHours(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMotorHours is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMotorHours requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMotorHours: %w", err)
	}
	return oldValue.MotorHours, nil
}

// AddMotorHours adds u to the "motorHours" field.
func (m *MachineMutation) AddMotorHours(u int) {
	if m.addmotorHours != nil {
		*m.addmotorHours += u
	} else {
		m.addmotorHours = &u
	}
}

// AddedMotorHours returns the value that was added to the "motorHours" field in this mutation.
func (m *MachineMutation) AddedMotorHours() (r int, exists bool) {
	v := m.addmotorHours
	if v == nil {
		return
	}
	return *v, true
}

// ResetMotorHours resets all changes to the "motorHours" field.
func (m *MachineMutation) ResetMotorHours() {
	m.motorHours = nil
	m.addmotorHours = nil
}

// SetDrive sets the "drive" field.
func (m *MachineMutation) SetDrive(s string) {
	m.drive = &s
}

// Drive returns the value of the "drive" field in the mutation.
func (m *MachineMutation) Drive() (r string, exists bool) {
	v := m.drive
	if v == nil {
		return
	}
	return *v, true
}

// OldDrive returns the old "drive" field's value of the Machine entity.
// If the Machine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MachineMutation) OldDrive(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDrive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDrive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDrive: %w", err)
	}
	return oldValue.Drive, nil
}

// ResetDrive resets all changes to the "drive" field.
func (m *MachineMutation) ResetDrive() {
	m.drive = nil
}

// SetWeight sets the "weight" field.
func (m *MachineMutation) SetWeight(u uint) {
	m.weight = &u
	m.addweight = nil
}

// Weight returns the value of the "weight" field in the mutation.
func (m *MachineMutation) Weight() (r uint, exists bool) {
	v := m.weight
	if v == nil {
		return
	}
	return *v, true
}

// OldWeight returns the old "weight" field's value of the Machine entity.
// If the Machine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MachineMutation) OldWeight(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWeight: %w", err)
	}
	return oldValue.Weight, nil
}

// AddWeight adds u to the "weight" field.
func (m *MachineMutation) AddWeight(u int) {
	if m.addweight != nil {
		*m.addweight += u
	} else {
		m.addweight = &u
	}
}

// AddedWeight returns the value that was added to the "weight" field in this mutation.
func (m *MachineMutation) AddedWeight() (r int, exists bool) {
	v := m.addweight
	if v == nil {
		return
	}
	return *v, true
}

// ResetWeight resets all changes to the "weight" field.
func (m *MachineMutation) ResetWeight() {
	m.weight = nil
	m.addweight = nil
}

// SetLoadCapacity sets the "loadCapacity" field.
func (m *MachineMutation) SetLoadCapacity(u uint) {
	m.loadCapacity = &u
	m.addloadCapacity = nil
}

// LoadCapacity returns the value of the "loadCapacity" field in the mutation.
func (m *MachineMutation) LoadCapacity() (r uint, exists bool) {
	v := m.loadCapacity
	if v == nil {
		return
	}
	return *v, true
}

// OldLoadCapacity returns the old "loadCapacity" field's value of the Machine entity.
// If the Machine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MachineMutation) OldLoadCapacity(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLoadCapacity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLoadCapacity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLoadCapacity: %w", err)
	}
	return oldValue.LoadCapacity, nil
}

// AddLoadCapacity adds u to the "loadCapacity" field.
func (m *MachineMutation) AddLoadCapacity(u int) {
	if m.addloadCapacity != nil {
		*m.addloadCapacity += u
	} else {
		m.addloadCapacity = &u
	}
}

// AddedLoadCapacity returns the value that was added to the "loadCapacity" field in this mutation.
func (m *MachineMutation) AddedLoadCapacity() (r int, exists bool) {
	v := m.addloadCapacity
	if v == nil {
		return
	}
	return *v, true
}

// ResetLoadCapacity resets all changes to the "loadCapacity" field.
func (m *MachineMutation) ResetLoadCapacity() {
	m.loadCapacity = nil
	m.addloadCapacity = nil
}

// SetRentPrice sets the "rentPrice" field.
func (m *MachineMutation) SetRentPrice(u uint) {
	m.rentPrice = &u
	m.addrentPrice = nil
}

// RentPrice returns the value of the "rentPrice" field in the mutation.
func (m *MachineMutation) RentPrice() (r uint, exists bool) {
	v := m.rentPrice
	if v == nil {
		return
	}
	return *v, true
}

// OldRentPrice returns the old "rentPrice" field's value of the Machine entity.
// If the Machine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MachineMutation) OldRentPrice(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRentPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRentPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRentPrice: %w", err)
	}
	return oldValue.RentPrice, nil
}

// AddRentPrice adds u to the "rentPrice" field.
func (m *MachineMutation) AddRentPrice(u int) {
	if m.addrentPrice != nil {
		*m.addrentPrice += u
	} else {
		m.addrentPrice = &u
	}
}

// AddedRentPrice returns the value that was added to the "rentPrice" field in this mutation.
func (m *MachineMutation) AddedRentPrice() (r int, exists bool) {
	v := m.addrentPrice
	if v == nil {
		return
	}
	return *v, true
}

// ClearRentPrice clears the value of the "rentPrice" field.
func (m *MachineMutation) ClearRentPrice() {
	m.rentPrice = nil
	m.addrentPrice = nil
	m.clearedFields[machine.FieldRentPrice] = struct{}{}
}

// RentPriceCleared returns if the "rentPrice" field was cleared in this mutation.
func (m *MachineMutation) RentPriceCleared() bool {
	_, ok := m.clearedFields[machine.FieldRentPrice]
	return ok
}

// ResetRentPrice resets all changes to the "rentPrice" field.
func (m *MachineMutation) ResetRentPrice() {
	m.rentPrice = nil
	m.addrentPrice = nil
	delete(m.clearedFields, machine.FieldRentPrice)
}

// SetSalePrice sets the "salePrice" field.
func (m *MachineMutation) SetSalePrice(u uint) {
	m.salePrice = &u
	m.addsalePrice = nil
}

// SalePrice returns the value of the "salePrice" field in the mutation.
func (m *MachineMutation) SalePrice() (r uint, exists bool) {
	v := m.salePrice
	if v == nil {
		return
	}
	return *v, true
}

// OldSalePrice returns the old "salePrice" field's value of the Machine entity.
// If the Machine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MachineMutation) OldSalePrice(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSalePrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSalePrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSalePrice: %w", err)
	}
	return oldValue.SalePrice, nil
}

// AddSalePrice adds u to the "salePrice" field.
func (m *MachineMutation) AddSalePrice(u int) {
	if m.addsalePrice != nil {
		*m.addsalePrice += u
	} else {
		m.addsalePrice = &u
	}
}

// AddedSalePrice returns the value that was added to the "salePrice" field in this mutation.
func (m *MachineMutation) AddedSalePrice() (r int, exists bool) {
	v := m.addsalePrice
	if v == nil {
		return
	}
	return *v, true
}

// ResetSalePrice resets all changes to the "salePrice" field.
func (m *MachineMutation) ResetSalePrice() {
	m.salePrice = nil
	m.addsalePrice = nil
}

// SetDescription sets the "description" field.
func (m *MachineMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *MachineMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Machine entity.
// If the Machine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MachineMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *MachineMutation) ResetDescription() {
	m.description = nil
}

// SetHidden sets the "hidden" field.
func (m *MachineMutation) SetHidden(b bool) {
	m.hidden = &b
}

// Hidden returns the value of the "hidden" field in the mutation.
func (m *MachineMutation) Hidden() (r bool, exists bool) {
	v := m.hidden
	if v == nil {
		return
	}
	return *v, true
}

// OldHidden returns the old "hidden" field's value of the Machine entity.
// If the Machine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MachineMutation) OldHidden(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHidden is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHidden requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHidden: %w", err)
	}
	return oldValue.Hidden, nil
}

// ResetHidden resets all changes to the "hidden" field.
func (m *MachineMutation) ResetHidden() {
	m.hidden = nil
}

// SetDeleted sets the "deleted" field.
func (m *MachineMutation) SetDeleted(b bool) {
	m.deleted = &b
}

// Deleted returns the value of the "deleted" field in the mutation.
func (m *MachineMutation) Deleted() (r bool, exists bool) {
	v := m.deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleted returns the old "deleted" field's value of the Machine entity.
// If the Machine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MachineMutation) OldDeleted(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleted: %w", err)
	}
	return oldValue.Deleted, nil
}

// ResetDeleted resets all changes to the "deleted" field.
func (m *MachineMutation) ResetDeleted() {
	m.deleted = nil
}

// SetNumberOfImages sets the "numberOfImages" field.
func (m *MachineMutation) SetNumberOfImages(i int) {
	m.numberOfImages = &i
	m.addnumberOfImages = nil
}

// NumberOfImages returns the value of the "numberOfImages" field in the mutation.
func (m *MachineMutation) NumberOfImages() (r int, exists bool) {
	v := m.numberOfImages
	if v == nil {
		return
	}
	return *v, true
}

// OldNumberOfImages returns the old "numberOfImages" field's value of the Machine entity.
// If the Machine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MachineMutation) OldNumberOfImages(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNumberOfImages is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNumberOfImages requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumberOfImages: %w", err)
	}
	return oldValue.NumberOfImages, nil
}

// AddNumberOfImages adds i to the "numberOfImages" field.
func (m *MachineMutation) AddNumberOfImages(i int) {
	if m.addnumberOfImages != nil {
		*m.addnumberOfImages += i
	} else {
		m.addnumberOfImages = &i
	}
}

// AddedNumberOfImages returns the value that was added to the "numberOfImages" field in this mutation.
func (m *MachineMutation) AddedNumberOfImages() (r int, exists bool) {
	v := m.addnumberOfImages
	if v == nil {
		return
	}
	return *v, true
}

// ClearNumberOfImages clears the value of the "numberOfImages" field.
func (m *MachineMutation) ClearNumberOfImages() {
	m.numberOfImages = nil
	m.addnumberOfImages = nil
	m.clearedFields[machine.FieldNumberOfImages] = struct{}{}
}

// NumberOfImagesCleared returns if the "numberOfImages" field was cleared in this mutation.
func (m *MachineMutation) NumberOfImagesCleared() bool {
	_, ok := m.clearedFields[machine.FieldNumberOfImages]
	return ok
}

// ResetNumberOfImages resets all changes to the "numberOfImages" field.
func (m *MachineMutation) ResetNumberOfImages() {
	m.numberOfImages = nil
	m.addnumberOfImages = nil
	delete(m.clearedFields, machine.FieldNumberOfImages)
}

// SetInternalDescription sets the "internalDescription" field.
func (m *MachineMutation) SetInternalDescription(s string) {
	m.internalDescription = &s
}

// InternalDescription returns the value of the "internalDescription" field in the mutation.
func (m *MachineMutation) InternalDescription() (r string, exists bool) {
	v := m.internalDescription
	if v == nil {
		return
	}
	return *v, true
}

// OldInternalDescription returns the old "internalDescription" field's value of the Machine entity.
// If the Machine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MachineMutation) OldInternalDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInternalDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInternalDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInternalDescription: %w", err)
	}
	return oldValue.InternalDescription, nil
}

// ClearInternalDescription clears the value of the "internalDescription" field.
func (m *MachineMutation) ClearInternalDescription() {
	m.internalDescription = nil
	m.clearedFields[machine.FieldInternalDescription] = struct{}{}
}

// InternalDescriptionCleared returns if the "internalDescription" field was cleared in this mutation.
func (m *MachineMutation) InternalDescriptionCleared() bool {
	_, ok := m.clearedFields[machine.FieldInternalDescription]
	return ok
}

// ResetInternalDescription resets all changes to the "internalDescription" field.
func (m *MachineMutation) ResetInternalDescription() {
	m.internalDescription = nil
	delete(m.clearedFields, machine.FieldInternalDescription)
}

// AddMachineSpecificationIDs adds the "machineSpecification" edge to the MachineSpecification entity by ids.
func (m *MachineMutation) AddMachineSpecificationIDs(ids ...int) {
	if m.machineSpecification == nil {
		m.machineSpecification = make(map[int]struct{})
	}
	for i := range ids {
		m.machineSpecification[ids[i]] = struct{}{}
	}
}

// ClearMachineSpecification clears the "machineSpecification" edge to the MachineSpecification entity.
func (m *MachineMutation) ClearMachineSpecification() {
	m.clearedmachineSpecification = true
}

// MachineSpecificationCleared reports if the "machineSpecification" edge to the MachineSpecification entity was cleared.
func (m *MachineMutation) MachineSpecificationCleared() bool {
	return m.clearedmachineSpecification
}

// RemoveMachineSpecificationIDs removes the "machineSpecification" edge to the MachineSpecification entity by IDs.
func (m *MachineMutation) RemoveMachineSpecificationIDs(ids ...int) {
	if m.removedmachineSpecification == nil {
		m.removedmachineSpecification = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.machineSpecification, ids[i])
		m.removedmachineSpecification[ids[i]] = struct{}{}
	}
}

// RemovedMachineSpecification returns the removed IDs of the "machineSpecification" edge to the MachineSpecification entity.
func (m *MachineMutation) RemovedMachineSpecificationIDs() (ids []int) {
	for id := range m.removedmachineSpecification {
		ids = append(ids, id)
	}
	return
}

// MachineSpecificationIDs returns the "machineSpecification" edge IDs in the mutation.
func (m *MachineMutation) MachineSpecificationIDs() (ids []int) {
	for id := range m.machineSpecification {
		ids = append(ids, id)
	}
	return
}

// ResetMachineSpecification resets all changes to the "machineSpecification" edge.
func (m *MachineMutation) ResetMachineSpecification() {
	m.machineSpecification = nil
	m.clearedmachineSpecification = false
	m.removedmachineSpecification = nil
}

// AddMachineAccessoryIDs adds the "machineAccessories" edge to the MachineAccessories entity by ids.
func (m *MachineMutation) AddMachineAccessoryIDs(ids ...int) {
	if m.machineAccessories == nil {
		m.machineAccessories = make(map[int]struct{})
	}
	for i := range ids {
		m.machineAccessories[ids[i]] = struct{}{}
	}
}

// ClearMachineAccessories clears the "machineAccessories" edge to the MachineAccessories entity.
func (m *MachineMutation) ClearMachineAccessories() {
	m.clearedmachineAccessories = true
}

// MachineAccessoriesCleared reports if the "machineAccessories" edge to the MachineAccessories entity was cleared.
func (m *MachineMutation) MachineAccessoriesCleared() bool {
	return m.clearedmachineAccessories
}

// RemoveMachineAccessoryIDs removes the "machineAccessories" edge to the MachineAccessories entity by IDs.
func (m *MachineMutation) RemoveMachineAccessoryIDs(ids ...int) {
	if m.removedmachineAccessories == nil {
		m.removedmachineAccessories = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.machineAccessories, ids[i])
		m.removedmachineAccessories[ids[i]] = struct{}{}
	}
}

// RemovedMachineAccessories returns the removed IDs of the "machineAccessories" edge to the MachineAccessories entity.
func (m *MachineMutation) RemovedMachineAccessoriesIDs() (ids []int) {
	for id := range m.removedmachineAccessories {
		ids = append(ids, id)
	}
	return
}

// MachineAccessoriesIDs returns the "machineAccessories" edge IDs in the mutation.
func (m *MachineMutation) MachineAccessoriesIDs() (ids []int) {
	for id := range m.machineAccessories {
		ids = append(ids, id)
	}
	return
}

// ResetMachineAccessories resets all changes to the "machineAccessories" edge.
func (m *MachineMutation) ResetMachineAccessories() {
	m.machineAccessories = nil
	m.clearedmachineAccessories = false
	m.removedmachineAccessories = nil
}

// Where appends a list predicates to the MachineMutation builder.
func (m *MachineMutation) Where(ps ...predicate.Machine) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *MachineMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Machine).
func (m *MachineMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MachineMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.name != nil {
		fields = append(fields, machine.FieldName)
	}
	if m.year != nil {
		fields = append(fields, machine.FieldYear)
	}
	if m.liftHeight != nil {
		fields = append(fields, machine.FieldLiftHeight)
	}
	if m.motorHours != nil {
		fields = append(fields, machine.FieldMotorHours)
	}
	if m.drive != nil {
		fields = append(fields, machine.FieldDrive)
	}
	if m.weight != nil {
		fields = append(fields, machine.FieldWeight)
	}
	if m.loadCapacity != nil {
		fields = append(fields, machine.FieldLoadCapacity)
	}
	if m.rentPrice != nil {
		fields = append(fields, machine.FieldRentPrice)
	}
	if m.salePrice != nil {
		fields = append(fields, machine.FieldSalePrice)
	}
	if m.description != nil {
		fields = append(fields, machine.FieldDescription)
	}
	if m.hidden != nil {
		fields = append(fields, machine.FieldHidden)
	}
	if m.deleted != nil {
		fields = append(fields, machine.FieldDeleted)
	}
	if m.numberOfImages != nil {
		fields = append(fields, machine.FieldNumberOfImages)
	}
	if m.internalDescription != nil {
		fields = append(fields, machine.FieldInternalDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MachineMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case machine.FieldName:
		return m.Name()
	case machine.FieldYear:
		return m.Year()
	case machine.FieldLiftHeight:
		return m.LiftHeight()
	case machine.FieldMotorHours:
		return m.MotorHours()
	case machine.FieldDrive:
		return m.Drive()
	case machine.FieldWeight:
		return m.Weight()
	case machine.FieldLoadCapacity:
		return m.LoadCapacity()
	case machine.FieldRentPrice:
		return m.RentPrice()
	case machine.FieldSalePrice:
		return m.SalePrice()
	case machine.FieldDescription:
		return m.Description()
	case machine.FieldHidden:
		return m.Hidden()
	case machine.FieldDeleted:
		return m.Deleted()
	case machine.FieldNumberOfImages:
		return m.NumberOfImages()
	case machine.FieldInternalDescription:
		return m.InternalDescription()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MachineMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case machine.FieldName:
		return m.OldName(ctx)
	case machine.FieldYear:
		return m.OldYear(ctx)
	case machine.FieldLiftHeight:
		return m.OldLiftHeight(ctx)
	case machine.FieldMotorHours:
		return m.OldMotorHours(ctx)
	case machine.FieldDrive:
		return m.OldDrive(ctx)
	case machine.FieldWeight:
		return m.OldWeight(ctx)
	case machine.FieldLoadCapacity:
		return m.OldLoadCapacity(ctx)
	case machine.FieldRentPrice:
		return m.OldRentPrice(ctx)
	case machine.FieldSalePrice:
		return m.OldSalePrice(ctx)
	case machine.FieldDescription:
		return m.OldDescription(ctx)
	case machine.FieldHidden:
		return m.OldHidden(ctx)
	case machine.FieldDeleted:
		return m.OldDeleted(ctx)
	case machine.FieldNumberOfImages:
		return m.OldNumberOfImages(ctx)
	case machine.FieldInternalDescription:
		return m.OldInternalDescription(ctx)
	}
	return nil, fmt.Errorf("unknown Machine field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MachineMutation) SetField(name string, value ent.Value) error {
	switch name {
	case machine.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case machine.FieldYear:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetYear(v)
		return nil
	case machine.FieldLiftHeight:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLiftHeight(v)
		return nil
	case machine.FieldMotorHours:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMotorHours(v)
		return nil
	case machine.FieldDrive:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDrive(v)
		return nil
	case machine.FieldWeight:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWeight(v)
		return nil
	case machine.FieldLoadCapacity:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLoadCapacity(v)
		return nil
	case machine.FieldRentPrice:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRentPrice(v)
		return nil
	case machine.FieldSalePrice:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSalePrice(v)
		return nil
	case machine.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case machine.FieldHidden:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHidden(v)
		return nil
	case machine.FieldDeleted:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleted(v)
		return nil
	case machine.FieldNumberOfImages:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumberOfImages(v)
		return nil
	case machine.FieldInternalDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInternalDescription(v)
		return nil
	}
	return fmt.Errorf("unknown Machine field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MachineMutation) AddedFields() []string {
	var fields []string
	if m.addyear != nil {
		fields = append(fields, machine.FieldYear)
	}
	if m.addliftHeight != nil {
		fields = append(fields, machine.FieldLiftHeight)
	}
	if m.addmotorHours != nil {
		fields = append(fields, machine.FieldMotorHours)
	}
	if m.addweight != nil {
		fields = append(fields, machine.FieldWeight)
	}
	if m.addloadCapacity != nil {
		fields = append(fields, machine.FieldLoadCapacity)
	}
	if m.addrentPrice != nil {
		fields = append(fields, machine.FieldRentPrice)
	}
	if m.addsalePrice != nil {
		fields = append(fields, machine.FieldSalePrice)
	}
	if m.addnumberOfImages != nil {
		fields = append(fields, machine.FieldNumberOfImages)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MachineMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case machine.FieldYear:
		return m.AddedYear()
	case machine.FieldLiftHeight:
		return m.AddedLiftHeight()
	case machine.FieldMotorHours:
		return m.AddedMotorHours()
	case machine.FieldWeight:
		return m.AddedWeight()
	case machine.FieldLoadCapacity:
		return m.AddedLoadCapacity()
	case machine.FieldRentPrice:
		return m.AddedRentPrice()
	case machine.FieldSalePrice:
		return m.AddedSalePrice()
	case machine.FieldNumberOfImages:
		return m.AddedNumberOfImages()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MachineMutation) AddField(name string, value ent.Value) error {
	switch name {
	case machine.FieldYear:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddYear(v)
		return nil
	case machine.FieldLiftHeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLiftHeight(v)
		return nil
	case machine.FieldMotorHours:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMotorHours(v)
		return nil
	case machine.FieldWeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWeight(v)
		return nil
	case machine.FieldLoadCapacity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLoadCapacity(v)
		return nil
	case machine.FieldRentPrice:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRentPrice(v)
		return nil
	case machine.FieldSalePrice:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSalePrice(v)
		return nil
	case machine.FieldNumberOfImages:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNumberOfImages(v)
		return nil
	}
	return fmt.Errorf("unknown Machine numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MachineMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(machine.FieldRentPrice) {
		fields = append(fields, machine.FieldRentPrice)
	}
	if m.FieldCleared(machine.FieldNumberOfImages) {
		fields = append(fields, machine.FieldNumberOfImages)
	}
	if m.FieldCleared(machine.FieldInternalDescription) {
		fields = append(fields, machine.FieldInternalDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MachineMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MachineMutation) ClearField(name string) error {
	switch name {
	case machine.FieldRentPrice:
		m.ClearRentPrice()
		return nil
	case machine.FieldNumberOfImages:
		m.ClearNumberOfImages()
		return nil
	case machine.FieldInternalDescription:
		m.ClearInternalDescription()
		return nil
	}
	return fmt.Errorf("unknown Machine nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MachineMutation) ResetField(name string) error {
	switch name {
	case machine.FieldName:
		m.ResetName()
		return nil
	case machine.FieldYear:
		m.ResetYear()
		return nil
	case machine.FieldLiftHeight:
		m.ResetLiftHeight()
		return nil
	case machine.FieldMotorHours:
		m.ResetMotorHours()
		return nil
	case machine.FieldDrive:
		m.ResetDrive()
		return nil
	case machine.FieldWeight:
		m.ResetWeight()
		return nil
	case machine.FieldLoadCapacity:
		m.ResetLoadCapacity()
		return nil
	case machine.FieldRentPrice:
		m.ResetRentPrice()
		return nil
	case machine.FieldSalePrice:
		m.ResetSalePrice()
		return nil
	case machine.FieldDescription:
		m.ResetDescription()
		return nil
	case machine.FieldHidden:
		m.ResetHidden()
		return nil
	case machine.FieldDeleted:
		m.ResetDeleted()
		return nil
	case machine.FieldNumberOfImages:
		m.ResetNumberOfImages()
		return nil
	case machine.FieldInternalDescription:
		m.ResetInternalDescription()
		return nil
	}
	return fmt.Errorf("unknown Machine field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MachineMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.machineSpecification != nil {
		edges = append(edges, machine.EdgeMachineSpecification)
	}
	if m.machineAccessories != nil {
		edges = append(edges, machine.EdgeMachineAccessories)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MachineMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case machine.EdgeMachineSpecification:
		ids := make([]ent.Value, 0, len(m.machineSpecification))
		for id := range m.machineSpecification {
			ids = append(ids, id)
		}
		return ids
	case machine.EdgeMachineAccessories:
		ids := make([]ent.Value, 0, len(m.machineAccessories))
		for id := range m.machineAccessories {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MachineMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedmachineSpecification != nil {
		edges = append(edges, machine.EdgeMachineSpecification)
	}
	if m.removedmachineAccessories != nil {
		edges = append(edges, machine.EdgeMachineAccessories)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MachineMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case machine.EdgeMachineSpecification:
		ids := make([]ent.Value, 0, len(m.removedmachineSpecification))
		for id := range m.removedmachineSpecification {
			ids = append(ids, id)
		}
		return ids
	case machine.EdgeMachineAccessories:
		ids := make([]ent.Value, 0, len(m.removedmachineAccessories))
		for id := range m.removedmachineAccessories {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MachineMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedmachineSpecification {
		edges = append(edges, machine.EdgeMachineSpecification)
	}
	if m.clearedmachineAccessories {
		edges = append(edges, machine.EdgeMachineAccessories)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MachineMutation) EdgeCleared(name string) bool {
	switch name {
	case machine.EdgeMachineSpecification:
		return m.clearedmachineSpecification
	case machine.EdgeMachineAccessories:
		return m.clearedmachineAccessories
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MachineMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Machine unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MachineMutation) ResetEdge(name string) error {
	switch name {
	case machine.EdgeMachineSpecification:
		m.ResetMachineSpecification()
		return nil
	case machine.EdgeMachineAccessories:
		m.ResetMachineAccessories()
		return nil
	}
	return fmt.Errorf("unknown Machine edge %s", name)
}

// MachineAccessoriesMutation represents an operation that mutates the MachineAccessories nodes in the graph.
type MachineAccessoriesMutation struct {
	config
	op             Op
	typ            string
	id             *int
	name1          *string
	name2          *string
	name3          *string
	name4          *string
	name5          *string
	name6          *string
	name7          *string
	name8          *string
	name9          *string
	name10         *string
	clearedFields  map[string]struct{}
	machine        *int
	clearedmachine bool
	done           bool
	oldValue       func(context.Context) (*MachineAccessories, error)
	predicates     []predicate.MachineAccessories
}

var _ ent.Mutation = (*MachineAccessoriesMutation)(nil)

// machineaccessoriesOption allows management of the mutation configuration using functional options.
type machineaccessoriesOption func(*MachineAccessoriesMutation)

// newMachineAccessoriesMutation creates new mutation for the MachineAccessories entity.
func newMachineAccessoriesMutation(c config, op Op, opts ...machineaccessoriesOption) *MachineAccessoriesMutation {
	m := &MachineAccessoriesMutation{
		config:        c,
		op:            op,
		typ:           TypeMachineAccessories,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMachineAccessoriesID sets the ID field of the mutation.
func withMachineAccessoriesID(id int) machineaccessoriesOption {
	return func(m *MachineAccessoriesMutation) {
		var (
			err   error
			once  sync.Once
			value *MachineAccessories
		)
		m.oldValue = func(ctx context.Context) (*MachineAccessories, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MachineAccessories.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMachineAccessories sets the old MachineAccessories of the mutation.
func withMachineAccessories(node *MachineAccessories) machineaccessoriesOption {
	return func(m *MachineAccessoriesMutation) {
		m.oldValue = func(context.Context) (*MachineAccessories, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MachineAccessoriesMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MachineAccessoriesMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MachineAccessoriesMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MachineAccessoriesMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MachineAccessories.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName1 sets the "name1" field.
func (m *MachineAccessoriesMutation) SetName1(s string) {
	m.name1 = &s
}

// Name1 returns the value of the "name1" field in the mutation.
func (m *MachineAccessoriesMutation) Name1() (r string, exists bool) {
	v := m.name1
	if v == nil {
		return
	}
	return *v, true
}

// OldName1 returns the old "name1" field's value of the MachineAccessories entity.
// If the MachineAccessories object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MachineAccessoriesMutation) OldName1(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName1 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName1: %w", err)
	}
	return oldValue.Name1, nil
}

// ClearName1 clears the value of the "name1" field.
func (m *MachineAccessoriesMutation) ClearName1() {
	m.name1 = nil
	m.clearedFields[machineaccessories.FieldName1] = struct{}{}
}

// Name1Cleared returns if the "name1" field was cleared in this mutation.
func (m *MachineAccessoriesMutation) Name1Cleared() bool {
	_, ok := m.clearedFields[machineaccessories.FieldName1]
	return ok
}

// ResetName1 resets all changes to the "name1" field.
func (m *MachineAccessoriesMutation) ResetName1() {
	m.name1 = nil
	delete(m.clearedFields, machineaccessories.FieldName1)
}

// SetName2 sets the "name2" field.
func (m *MachineAccessoriesMutation) SetName2(s string) {
	m.name2 = &s
}

// Name2 returns the value of the "name2" field in the mutation.
func (m *MachineAccessoriesMutation) Name2() (r string, exists bool) {
	v := m.name2
	if v == nil {
		return
	}
	return *v, true
}

// OldName2 returns the old "name2" field's value of the MachineAccessories entity.
// If the MachineAccessories object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MachineAccessoriesMutation) OldName2(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName2 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName2 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName2: %w", err)
	}
	return oldValue.Name2, nil
}

// ClearName2 clears the value of the "name2" field.
func (m *MachineAccessoriesMutation) ClearName2() {
	m.name2 = nil
	m.clearedFields[machineaccessories.FieldName2] = struct{}{}
}

// Name2Cleared returns if the "name2" field was cleared in this mutation.
func (m *MachineAccessoriesMutation) Name2Cleared() bool {
	_, ok := m.clearedFields[machineaccessories.FieldName2]
	return ok
}

// ResetName2 resets all changes to the "name2" field.
func (m *MachineAccessoriesMutation) ResetName2() {
	m.name2 = nil
	delete(m.clearedFields, machineaccessories.FieldName2)
}

// SetName3 sets the "name3" field.
func (m *MachineAccessoriesMutation) SetName3(s string) {
	m.name3 = &s
}

// Name3 returns the value of the "name3" field in the mutation.
func (m *MachineAccessoriesMutation) Name3() (r string, exists bool) {
	v := m.name3
	if v == nil {
		return
	}
	return *v, true
}

// OldName3 returns the old "name3" field's value of the MachineAccessories entity.
// If the MachineAccessories object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MachineAccessoriesMutation) OldName3(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName3 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName3 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName3: %w", err)
	}
	return oldValue.Name3, nil
}

// ClearName3 clears the value of the "name3" field.
func (m *MachineAccessoriesMutation) ClearName3() {
	m.name3 = nil
	m.clearedFields[machineaccessories.FieldName3] = struct{}{}
}

// Name3Cleared returns if the "name3" field was cleared in this mutation.
func (m *MachineAccessoriesMutation) Name3Cleared() bool {
	_, ok := m.clearedFields[machineaccessories.FieldName3]
	return ok
}

// ResetName3 resets all changes to the "name3" field.
func (m *MachineAccessoriesMutation) ResetName3() {
	m.name3 = nil
	delete(m.clearedFields, machineaccessories.FieldName3)
}

// SetName4 sets the "name4" field.
func (m *MachineAccessoriesMutation) SetName4(s string) {
	m.name4 = &s
}

// Name4 returns the value of the "name4" field in the mutation.
func (m *MachineAccessoriesMutation) Name4() (r string, exists bool) {
	v := m.name4
	if v == nil {
		return
	}
	return *v, true
}

// OldName4 returns the old "name4" field's value of the MachineAccessories entity.
// If the MachineAccessories object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MachineAccessoriesMutation) OldName4(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName4 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName4 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName4: %w", err)
	}
	return oldValue.Name4, nil
}

// ClearName4 clears the value of the "name4" field.
func (m *MachineAccessoriesMutation) ClearName4() {
	m.name4 = nil
	m.clearedFields[machineaccessories.FieldName4] = struct{}{}
}

// Name4Cleared returns if the "name4" field was cleared in this mutation.
func (m *MachineAccessoriesMutation) Name4Cleared() bool {
	_, ok := m.clearedFields[machineaccessories.FieldName4]
	return ok
}

// ResetName4 resets all changes to the "name4" field.
func (m *MachineAccessoriesMutation) ResetName4() {
	m.name4 = nil
	delete(m.clearedFields, machineaccessories.FieldName4)
}

// SetName5 sets the "name5" field.
func (m *MachineAccessoriesMutation) SetName5(s string) {
	m.name5 = &s
}

// Name5 returns the value of the "name5" field in the mutation.
func (m *MachineAccessoriesMutation) Name5() (r string, exists bool) {
	v := m.name5
	if v == nil {
		return
	}
	return *v, true
}

// OldName5 returns the old "name5" field's value of the MachineAccessories entity.
// If the MachineAccessories object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MachineAccessoriesMutation) OldName5(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName5 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName5 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName5: %w", err)
	}
	return oldValue.Name5, nil
}

// ClearName5 clears the value of the "name5" field.
func (m *MachineAccessoriesMutation) ClearName5() {
	m.name5 = nil
	m.clearedFields[machineaccessories.FieldName5] = struct{}{}
}

// Name5Cleared returns if the "name5" field was cleared in this mutation.
func (m *MachineAccessoriesMutation) Name5Cleared() bool {
	_, ok := m.clearedFields[machineaccessories.FieldName5]
	return ok
}

// ResetName5 resets all changes to the "name5" field.
func (m *MachineAccessoriesMutation) ResetName5() {
	m.name5 = nil
	delete(m.clearedFields, machineaccessories.FieldName5)
}

// SetName6 sets the "name6" field.
func (m *MachineAccessoriesMutation) SetName6(s string) {
	m.name6 = &s
}

// Name6 returns the value of the "name6" field in the mutation.
func (m *MachineAccessoriesMutation) Name6() (r string, exists bool) {
	v := m.name6
	if v == nil {
		return
	}
	return *v, true
}

// OldName6 returns the old "name6" field's value of the MachineAccessories entity.
// If the MachineAccessories object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MachineAccessoriesMutation) OldName6(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName6 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName6 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName6: %w", err)
	}
	return oldValue.Name6, nil
}

// ClearName6 clears the value of the "name6" field.
func (m *MachineAccessoriesMutation) ClearName6() {
	m.name6 = nil
	m.clearedFields[machineaccessories.FieldName6] = struct{}{}
}

// Name6Cleared returns if the "name6" field was cleared in this mutation.
func (m *MachineAccessoriesMutation) Name6Cleared() bool {
	_, ok := m.clearedFields[machineaccessories.FieldName6]
	return ok
}

// ResetName6 resets all changes to the "name6" field.
func (m *MachineAccessoriesMutation) ResetName6() {
	m.name6 = nil
	delete(m.clearedFields, machineaccessories.FieldName6)
}

// SetName7 sets the "name7" field.
func (m *MachineAccessoriesMutation) SetName7(s string) {
	m.name7 = &s
}

// Name7 returns the value of the "name7" field in the mutation.
func (m *MachineAccessoriesMutation) Name7() (r string, exists bool) {
	v := m.name7
	if v == nil {
		return
	}
	return *v, true
}

// OldName7 returns the old "name7" field's value of the MachineAccessories entity.
// If the MachineAccessories object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MachineAccessoriesMutation) OldName7(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName7 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName7 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName7: %w", err)
	}
	return oldValue.Name7, nil
}

// ClearName7 clears the value of the "name7" field.
func (m *MachineAccessoriesMutation) ClearName7() {
	m.name7 = nil
	m.clearedFields[machineaccessories.FieldName7] = struct{}{}
}

// Name7Cleared returns if the "name7" field was cleared in this mutation.
func (m *MachineAccessoriesMutation) Name7Cleared() bool {
	_, ok := m.clearedFields[machineaccessories.FieldName7]
	return ok
}

// ResetName7 resets all changes to the "name7" field.
func (m *MachineAccessoriesMutation) ResetName7() {
	m.name7 = nil
	delete(m.clearedFields, machineaccessories.FieldName7)
}

// SetName8 sets the "name8" field.
func (m *MachineAccessoriesMutation) SetName8(s string) {
	m.name8 = &s
}

// Name8 returns the value of the "name8" field in the mutation.
func (m *MachineAccessoriesMutation) Name8() (r string, exists bool) {
	v := m.name8
	if v == nil {
		return
	}
	return *v, true
}

// OldName8 returns the old "name8" field's value of the MachineAccessories entity.
// If the MachineAccessories object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MachineAccessoriesMutation) OldName8(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName8 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName8 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName8: %w", err)
	}
	return oldValue.Name8, nil
}

// ClearName8 clears the value of the "name8" field.
func (m *MachineAccessoriesMutation) ClearName8() {
	m.name8 = nil
	m.clearedFields[machineaccessories.FieldName8] = struct{}{}
}

// Name8Cleared returns if the "name8" field was cleared in this mutation.
func (m *MachineAccessoriesMutation) Name8Cleared() bool {
	_, ok := m.clearedFields[machineaccessories.FieldName8]
	return ok
}

// ResetName8 resets all changes to the "name8" field.
func (m *MachineAccessoriesMutation) ResetName8() {
	m.name8 = nil
	delete(m.clearedFields, machineaccessories.FieldName8)
}

// SetName9 sets the "name9" field.
func (m *MachineAccessoriesMutation) SetName9(s string) {
	m.name9 = &s
}

// Name9 returns the value of the "name9" field in the mutation.
func (m *MachineAccessoriesMutation) Name9() (r string, exists bool) {
	v := m.name9
	if v == nil {
		return
	}
	return *v, true
}

// OldName9 returns the old "name9" field's value of the MachineAccessories entity.
// If the MachineAccessories object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MachineAccessoriesMutation) OldName9(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName9 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName9 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName9: %w", err)
	}
	return oldValue.Name9, nil
}

// ClearName9 clears the value of the "name9" field.
func (m *MachineAccessoriesMutation) ClearName9() {
	m.name9 = nil
	m.clearedFields[machineaccessories.FieldName9] = struct{}{}
}

// Name9Cleared returns if the "name9" field was cleared in this mutation.
func (m *MachineAccessoriesMutation) Name9Cleared() bool {
	_, ok := m.clearedFields[machineaccessories.FieldName9]
	return ok
}

// ResetName9 resets all changes to the "name9" field.
func (m *MachineAccessoriesMutation) ResetName9() {
	m.name9 = nil
	delete(m.clearedFields, machineaccessories.FieldName9)
}

// SetName10 sets the "name10" field.
func (m *MachineAccessoriesMutation) SetName10(s string) {
	m.name10 = &s
}

// Name10 returns the value of the "name10" field in the mutation.
func (m *MachineAccessoriesMutation) Name10() (r string, exists bool) {
	v := m.name10
	if v == nil {
		return
	}
	return *v, true
}

// OldName10 returns the old "name10" field's value of the MachineAccessories entity.
// If the MachineAccessories object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MachineAccessoriesMutation) OldName10(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName10 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName10 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName10: %w", err)
	}
	return oldValue.Name10, nil
}

// ClearName10 clears the value of the "name10" field.
func (m *MachineAccessoriesMutation) ClearName10() {
	m.name10 = nil
	m.clearedFields[machineaccessories.FieldName10] = struct{}{}
}

// Name10Cleared returns if the "name10" field was cleared in this mutation.
func (m *MachineAccessoriesMutation) Name10Cleared() bool {
	_, ok := m.clearedFields[machineaccessories.FieldName10]
	return ok
}

// ResetName10 resets all changes to the "name10" field.
func (m *MachineAccessoriesMutation) ResetName10() {
	m.name10 = nil
	delete(m.clearedFields, machineaccessories.FieldName10)
}

// SetMachineID sets the "machine" edge to the Machine entity by id.
func (m *MachineAccessoriesMutation) SetMachineID(id int) {
	m.machine = &id
}

// ClearMachine clears the "machine" edge to the Machine entity.
func (m *MachineAccessoriesMutation) ClearMachine() {
	m.clearedmachine = true
}

// MachineCleared reports if the "machine" edge to the Machine entity was cleared.
func (m *MachineAccessoriesMutation) MachineCleared() bool {
	return m.clearedmachine
}

// MachineID returns the "machine" edge ID in the mutation.
func (m *MachineAccessoriesMutation) MachineID() (id int, exists bool) {
	if m.machine != nil {
		return *m.machine, true
	}
	return
}

// MachineIDs returns the "machine" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MachineID instead. It exists only for internal usage by the builders.
func (m *MachineAccessoriesMutation) MachineIDs() (ids []int) {
	if id := m.machine; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMachine resets all changes to the "machine" edge.
func (m *MachineAccessoriesMutation) ResetMachine() {
	m.machine = nil
	m.clearedmachine = false
}

// Where appends a list predicates to the MachineAccessoriesMutation builder.
func (m *MachineAccessoriesMutation) Where(ps ...predicate.MachineAccessories) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *MachineAccessoriesMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (MachineAccessories).
func (m *MachineAccessoriesMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MachineAccessoriesMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.name1 != nil {
		fields = append(fields, machineaccessories.FieldName1)
	}
	if m.name2 != nil {
		fields = append(fields, machineaccessories.FieldName2)
	}
	if m.name3 != nil {
		fields = append(fields, machineaccessories.FieldName3)
	}
	if m.name4 != nil {
		fields = append(fields, machineaccessories.FieldName4)
	}
	if m.name5 != nil {
		fields = append(fields, machineaccessories.FieldName5)
	}
	if m.name6 != nil {
		fields = append(fields, machineaccessories.FieldName6)
	}
	if m.name7 != nil {
		fields = append(fields, machineaccessories.FieldName7)
	}
	if m.name8 != nil {
		fields = append(fields, machineaccessories.FieldName8)
	}
	if m.name9 != nil {
		fields = append(fields, machineaccessories.FieldName9)
	}
	if m.name10 != nil {
		fields = append(fields, machineaccessories.FieldName10)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MachineAccessoriesMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case machineaccessories.FieldName1:
		return m.Name1()
	case machineaccessories.FieldName2:
		return m.Name2()
	case machineaccessories.FieldName3:
		return m.Name3()
	case machineaccessories.FieldName4:
		return m.Name4()
	case machineaccessories.FieldName5:
		return m.Name5()
	case machineaccessories.FieldName6:
		return m.Name6()
	case machineaccessories.FieldName7:
		return m.Name7()
	case machineaccessories.FieldName8:
		return m.Name8()
	case machineaccessories.FieldName9:
		return m.Name9()
	case machineaccessories.FieldName10:
		return m.Name10()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MachineAccessoriesMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case machineaccessories.FieldName1:
		return m.OldName1(ctx)
	case machineaccessories.FieldName2:
		return m.OldName2(ctx)
	case machineaccessories.FieldName3:
		return m.OldName3(ctx)
	case machineaccessories.FieldName4:
		return m.OldName4(ctx)
	case machineaccessories.FieldName5:
		return m.OldName5(ctx)
	case machineaccessories.FieldName6:
		return m.OldName6(ctx)
	case machineaccessories.FieldName7:
		return m.OldName7(ctx)
	case machineaccessories.FieldName8:
		return m.OldName8(ctx)
	case machineaccessories.FieldName9:
		return m.OldName9(ctx)
	case machineaccessories.FieldName10:
		return m.OldName10(ctx)
	}
	return nil, fmt.Errorf("unknown MachineAccessories field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MachineAccessoriesMutation) SetField(name string, value ent.Value) error {
	switch name {
	case machineaccessories.FieldName1:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName1(v)
		return nil
	case machineaccessories.FieldName2:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName2(v)
		return nil
	case machineaccessories.FieldName3:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName3(v)
		return nil
	case machineaccessories.FieldName4:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName4(v)
		return nil
	case machineaccessories.FieldName5:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName5(v)
		return nil
	case machineaccessories.FieldName6:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName6(v)
		return nil
	case machineaccessories.FieldName7:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName7(v)
		return nil
	case machineaccessories.FieldName8:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName8(v)
		return nil
	case machineaccessories.FieldName9:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName9(v)
		return nil
	case machineaccessories.FieldName10:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName10(v)
		return nil
	}
	return fmt.Errorf("unknown MachineAccessories field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MachineAccessoriesMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MachineAccessoriesMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MachineAccessoriesMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown MachineAccessories numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MachineAccessoriesMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(machineaccessories.FieldName1) {
		fields = append(fields, machineaccessories.FieldName1)
	}
	if m.FieldCleared(machineaccessories.FieldName2) {
		fields = append(fields, machineaccessories.FieldName2)
	}
	if m.FieldCleared(machineaccessories.FieldName3) {
		fields = append(fields, machineaccessories.FieldName3)
	}
	if m.FieldCleared(machineaccessories.FieldName4) {
		fields = append(fields, machineaccessories.FieldName4)
	}
	if m.FieldCleared(machineaccessories.FieldName5) {
		fields = append(fields, machineaccessories.FieldName5)
	}
	if m.FieldCleared(machineaccessories.FieldName6) {
		fields = append(fields, machineaccessories.FieldName6)
	}
	if m.FieldCleared(machineaccessories.FieldName7) {
		fields = append(fields, machineaccessories.FieldName7)
	}
	if m.FieldCleared(machineaccessories.FieldName8) {
		fields = append(fields, machineaccessories.FieldName8)
	}
	if m.FieldCleared(machineaccessories.FieldName9) {
		fields = append(fields, machineaccessories.FieldName9)
	}
	if m.FieldCleared(machineaccessories.FieldName10) {
		fields = append(fields, machineaccessories.FieldName10)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MachineAccessoriesMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MachineAccessoriesMutation) ClearField(name string) error {
	switch name {
	case machineaccessories.FieldName1:
		m.ClearName1()
		return nil
	case machineaccessories.FieldName2:
		m.ClearName2()
		return nil
	case machineaccessories.FieldName3:
		m.ClearName3()
		return nil
	case machineaccessories.FieldName4:
		m.ClearName4()
		return nil
	case machineaccessories.FieldName5:
		m.ClearName5()
		return nil
	case machineaccessories.FieldName6:
		m.ClearName6()
		return nil
	case machineaccessories.FieldName7:
		m.ClearName7()
		return nil
	case machineaccessories.FieldName8:
		m.ClearName8()
		return nil
	case machineaccessories.FieldName9:
		m.ClearName9()
		return nil
	case machineaccessories.FieldName10:
		m.ClearName10()
		return nil
	}
	return fmt.Errorf("unknown MachineAccessories nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MachineAccessoriesMutation) ResetField(name string) error {
	switch name {
	case machineaccessories.FieldName1:
		m.ResetName1()
		return nil
	case machineaccessories.FieldName2:
		m.ResetName2()
		return nil
	case machineaccessories.FieldName3:
		m.ResetName3()
		return nil
	case machineaccessories.FieldName4:
		m.ResetName4()
		return nil
	case machineaccessories.FieldName5:
		m.ResetName5()
		return nil
	case machineaccessories.FieldName6:
		m.ResetName6()
		return nil
	case machineaccessories.FieldName7:
		m.ResetName7()
		return nil
	case machineaccessories.FieldName8:
		m.ResetName8()
		return nil
	case machineaccessories.FieldName9:
		m.ResetName9()
		return nil
	case machineaccessories.FieldName10:
		m.ResetName10()
		return nil
	}
	return fmt.Errorf("unknown MachineAccessories field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MachineAccessoriesMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.machine != nil {
		edges = append(edges, machineaccessories.EdgeMachine)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MachineAccessoriesMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case machineaccessories.EdgeMachine:
		if id := m.machine; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MachineAccessoriesMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MachineAccessoriesMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MachineAccessoriesMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedmachine {
		edges = append(edges, machineaccessories.EdgeMachine)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MachineAccessoriesMutation) EdgeCleared(name string) bool {
	switch name {
	case machineaccessories.EdgeMachine:
		return m.clearedmachine
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MachineAccessoriesMutation) ClearEdge(name string) error {
	switch name {
	case machineaccessories.EdgeMachine:
		m.ClearMachine()
		return nil
	}
	return fmt.Errorf("unknown MachineAccessories unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MachineAccessoriesMutation) ResetEdge(name string) error {
	switch name {
	case machineaccessories.EdgeMachine:
		m.ResetMachine()
		return nil
	}
	return fmt.Errorf("unknown MachineAccessories edge %s", name)
}

// MachineSpecificationMutation represents an operation that mutates the MachineSpecification nodes in the graph.
type MachineSpecificationMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	machineNumber        *int
	addmachineNumber     *int
	machineType          *string
	drive                *string
	loadCapacity         *uint
	addloadCapacity      *int
	year                 *uint
	addyear              *int
	motorHours           *uint
	addmotorHours        *int
	passingHeight        *uint
	addpassingHeight     *int
	liftHeight           *uint
	addliftHeight        *int
	weight               *uint
	addweight            *int
	forks                *string
	mastType             *string
	additionalAttributes *string
	equipment            *string
	engine               *string
	hydraulicControl     *string
	driveControl         *string
	cabin                *string
	lights               *string
	battery              *string
	clearedFields        map[string]struct{}
	machine              *int
	clearedmachine       bool
	done                 bool
	oldValue             func(context.Context) (*MachineSpecification, error)
	predicates           []predicate.MachineSpecification
}

var _ ent.Mutation = (*MachineSpecificationMutation)(nil)

// machinespecificationOption allows management of the mutation configuration using functional options.
type machinespecificationOption func(*MachineSpecificationMutation)

// newMachineSpecificationMutation creates new mutation for the MachineSpecification entity.
func newMachineSpecificationMutation(c config, op Op, opts ...machinespecificationOption) *MachineSpecificationMutation {
	m := &MachineSpecificationMutation{
		config:        c,
		op:            op,
		typ:           TypeMachineSpecification,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMachineSpecificationID sets the ID field of the mutation.
func withMachineSpecificationID(id int) machinespecificationOption {
	return func(m *MachineSpecificationMutation) {
		var (
			err   error
			once  sync.Once
			value *MachineSpecification
		)
		m.oldValue = func(ctx context.Context) (*MachineSpecification, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MachineSpecification.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMachineSpecification sets the old MachineSpecification of the mutation.
func withMachineSpecification(node *MachineSpecification) machinespecificationOption {
	return func(m *MachineSpecificationMutation) {
		m.oldValue = func(context.Context) (*MachineSpecification, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MachineSpecificationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MachineSpecificationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MachineSpecificationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MachineSpecificationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MachineSpecification.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetMachineNumber sets the "machineNumber" field.
func (m *MachineSpecificationMutation) SetMachineNumber(i int) {
	m.machineNumber = &i
	m.addmachineNumber = nil
}

// MachineNumber returns the value of the "machineNumber" field in the mutation.
func (m *MachineSpecificationMutation) MachineNumber() (r int, exists bool) {
	v := m.machineNumber
	if v == nil {
		return
	}
	return *v, true
}

// OldMachineNumber returns the old "machineNumber" field's value of the MachineSpecification entity.
// If the MachineSpecification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MachineSpecificationMutation) OldMachineNumber(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMachineNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMachineNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMachineNumber: %w", err)
	}
	return oldValue.MachineNumber, nil
}

// AddMachineNumber adds i to the "machineNumber" field.
func (m *MachineSpecificationMutation) AddMachineNumber(i int) {
	if m.addmachineNumber != nil {
		*m.addmachineNumber += i
	} else {
		m.addmachineNumber = &i
	}
}

// AddedMachineNumber returns the value that was added to the "machineNumber" field in this mutation.
func (m *MachineSpecificationMutation) AddedMachineNumber() (r int, exists bool) {
	v := m.addmachineNumber
	if v == nil {
		return
	}
	return *v, true
}

// ResetMachineNumber resets all changes to the "machineNumber" field.
func (m *MachineSpecificationMutation) ResetMachineNumber() {
	m.machineNumber = nil
	m.addmachineNumber = nil
}

// SetMachineType sets the "machineType" field.
func (m *MachineSpecificationMutation) SetMachineType(s string) {
	m.machineType = &s
}

// MachineType returns the value of the "machineType" field in the mutation.
func (m *MachineSpecificationMutation) MachineType() (r string, exists bool) {
	v := m.machineType
	if v == nil {
		return
	}
	return *v, true
}

// OldMachineType returns the old "machineType" field's value of the MachineSpecification entity.
// If the MachineSpecification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MachineSpecificationMutation) OldMachineType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMachineType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMachineType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMachineType: %w", err)
	}
	return oldValue.MachineType, nil
}

// ResetMachineType resets all changes to the "machineType" field.
func (m *MachineSpecificationMutation) ResetMachineType() {
	m.machineType = nil
}

// SetDrive sets the "drive" field.
func (m *MachineSpecificationMutation) SetDrive(s string) {
	m.drive = &s
}

// Drive returns the value of the "drive" field in the mutation.
func (m *MachineSpecificationMutation) Drive() (r string, exists bool) {
	v := m.drive
	if v == nil {
		return
	}
	return *v, true
}

// OldDrive returns the old "drive" field's value of the MachineSpecification entity.
// If the MachineSpecification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MachineSpecificationMutation) OldDrive(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDrive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDrive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDrive: %w", err)
	}
	return oldValue.Drive, nil
}

// ResetDrive resets all changes to the "drive" field.
func (m *MachineSpecificationMutation) ResetDrive() {
	m.drive = nil
}

// SetLoadCapacity sets the "loadCapacity" field.
func (m *MachineSpecificationMutation) SetLoadCapacity(u uint) {
	m.loadCapacity = &u
	m.addloadCapacity = nil
}

// LoadCapacity returns the value of the "loadCapacity" field in the mutation.
func (m *MachineSpecificationMutation) LoadCapacity() (r uint, exists bool) {
	v := m.loadCapacity
	if v == nil {
		return
	}
	return *v, true
}

// OldLoadCapacity returns the old "loadCapacity" field's value of the MachineSpecification entity.
// If the MachineSpecification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MachineSpecificationMutation) OldLoadCapacity(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLoadCapacity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLoadCapacity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLoadCapacity: %w", err)
	}
	return oldValue.LoadCapacity, nil
}

// AddLoadCapacity adds u to the "loadCapacity" field.
func (m *MachineSpecificationMutation) AddLoadCapacity(u int) {
	if m.addloadCapacity != nil {
		*m.addloadCapacity += u
	} else {
		m.addloadCapacity = &u
	}
}

// AddedLoadCapacity returns the value that was added to the "loadCapacity" field in this mutation.
func (m *MachineSpecificationMutation) AddedLoadCapacity() (r int, exists bool) {
	v := m.addloadCapacity
	if v == nil {
		return
	}
	return *v, true
}

// ResetLoadCapacity resets all changes to the "loadCapacity" field.
func (m *MachineSpecificationMutation) ResetLoadCapacity() {
	m.loadCapacity = nil
	m.addloadCapacity = nil
}

// SetYear sets the "year" field.
func (m *MachineSpecificationMutation) SetYear(u uint) {
	m.year = &u
	m.addyear = nil
}

// Year returns the value of the "year" field in the mutation.
func (m *MachineSpecificationMutation) Year() (r uint, exists bool) {
	v := m.year
	if v == nil {
		return
	}
	return *v, true
}

// OldYear returns the old "year" field's value of the MachineSpecification entity.
// If the MachineSpecification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MachineSpecificationMutation) OldYear(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldYear is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldYear requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldYear: %w", err)
	}
	return oldValue.Year, nil
}

// AddYear adds u to the "year" field.
func (m *MachineSpecificationMutation) AddYear(u int) {
	if m.addyear != nil {
		*m.addyear += u
	} else {
		m.addyear = &u
	}
}

// AddedYear returns the value that was added to the "year" field in this mutation.
func (m *MachineSpecificationMutation) AddedYear() (r int, exists bool) {
	v := m.addyear
	if v == nil {
		return
	}
	return *v, true
}

// ResetYear resets all changes to the "year" field.
func (m *MachineSpecificationMutation) ResetYear() {
	m.year = nil
	m.addyear = nil
}

// SetMotorHours sets the "motorHours" field.
func (m *MachineSpecificationMutation) SetMotorHours(u uint) {
	m.motorHours = &u
	m.addmotorHours = nil
}

// MotorHours returns the value of the "motorHours" field in the mutation.
func (m *MachineSpecificationMutation) MotorHours() (r uint, exists bool) {
	v := m.motorHours
	if v == nil {
		return
	}
	return *v, true
}

// OldMotorHours returns the old "motorHours" field's value of the MachineSpecification entity.
// If the MachineSpecification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MachineSpecificationMutation) OldMotorHours(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMotorHours is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMotorHours requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMotorHours: %w", err)
	}
	return oldValue.MotorHours, nil
}

// AddMotorHours adds u to the "motorHours" field.
func (m *MachineSpecificationMutation) AddMotorHours(u int) {
	if m.addmotorHours != nil {
		*m.addmotorHours += u
	} else {
		m.addmotorHours = &u
	}
}

// AddedMotorHours returns the value that was added to the "motorHours" field in this mutation.
func (m *MachineSpecificationMutation) AddedMotorHours() (r int, exists bool) {
	v := m.addmotorHours
	if v == nil {
		return
	}
	return *v, true
}

// ResetMotorHours resets all changes to the "motorHours" field.
func (m *MachineSpecificationMutation) ResetMotorHours() {
	m.motorHours = nil
	m.addmotorHours = nil
}

// SetPassingHeight sets the "passingHeight" field.
func (m *MachineSpecificationMutation) SetPassingHeight(u uint) {
	m.passingHeight = &u
	m.addpassingHeight = nil
}

// PassingHeight returns the value of the "passingHeight" field in the mutation.
func (m *MachineSpecificationMutation) PassingHeight() (r uint, exists bool) {
	v := m.passingHeight
	if v == nil {
		return
	}
	return *v, true
}

// OldPassingHeight returns the old "passingHeight" field's value of the MachineSpecification entity.
// If the MachineSpecification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MachineSpecificationMutation) OldPassingHeight(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassingHeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassingHeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassingHeight: %w", err)
	}
	return oldValue.PassingHeight, nil
}

// AddPassingHeight adds u to the "passingHeight" field.
func (m *MachineSpecificationMutation) AddPassingHeight(u int) {
	if m.addpassingHeight != nil {
		*m.addpassingHeight += u
	} else {
		m.addpassingHeight = &u
	}
}

// AddedPassingHeight returns the value that was added to the "passingHeight" field in this mutation.
func (m *MachineSpecificationMutation) AddedPassingHeight() (r int, exists bool) {
	v := m.addpassingHeight
	if v == nil {
		return
	}
	return *v, true
}

// ClearPassingHeight clears the value of the "passingHeight" field.
func (m *MachineSpecificationMutation) ClearPassingHeight() {
	m.passingHeight = nil
	m.addpassingHeight = nil
	m.clearedFields[machinespecification.FieldPassingHeight] = struct{}{}
}

// PassingHeightCleared returns if the "passingHeight" field was cleared in this mutation.
func (m *MachineSpecificationMutation) PassingHeightCleared() bool {
	_, ok := m.clearedFields[machinespecification.FieldPassingHeight]
	return ok
}

// ResetPassingHeight resets all changes to the "passingHeight" field.
func (m *MachineSpecificationMutation) ResetPassingHeight() {
	m.passingHeight = nil
	m.addpassingHeight = nil
	delete(m.clearedFields, machinespecification.FieldPassingHeight)
}

// SetLiftHeight sets the "liftHeight" field.
func (m *MachineSpecificationMutation) SetLiftHeight(u uint) {
	m.liftHeight = &u
	m.addliftHeight = nil
}

// LiftHeight returns the value of the "liftHeight" field in the mutation.
func (m *MachineSpecificationMutation) LiftHeight() (r uint, exists bool) {
	v := m.liftHeight
	if v == nil {
		return
	}
	return *v, true
}

// OldLiftHeight returns the old "liftHeight" field's value of the MachineSpecification entity.
// If the MachineSpecification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MachineSpecificationMutation) OldLiftHeight(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLiftHeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLiftHeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLiftHeight: %w", err)
	}
	return oldValue.LiftHeight, nil
}

// AddLiftHeight adds u to the "liftHeight" field.
func (m *MachineSpecificationMutation) AddLiftHeight(u int) {
	if m.addliftHeight != nil {
		*m.addliftHeight += u
	} else {
		m.addliftHeight = &u
	}
}

// AddedLiftHeight returns the value that was added to the "liftHeight" field in this mutation.
func (m *MachineSpecificationMutation) AddedLiftHeight() (r int, exists bool) {
	v := m.addliftHeight
	if v == nil {
		return
	}
	return *v, true
}

// ResetLiftHeight resets all changes to the "liftHeight" field.
func (m *MachineSpecificationMutation) ResetLiftHeight() {
	m.liftHeight = nil
	m.addliftHeight = nil
}

// SetWeight sets the "weight" field.
func (m *MachineSpecificationMutation) SetWeight(u uint) {
	m.weight = &u
	m.addweight = nil
}

// Weight returns the value of the "weight" field in the mutation.
func (m *MachineSpecificationMutation) Weight() (r uint, exists bool) {
	v := m.weight
	if v == nil {
		return
	}
	return *v, true
}

// OldWeight returns the old "weight" field's value of the MachineSpecification entity.
// If the MachineSpecification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MachineSpecificationMutation) OldWeight(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWeight: %w", err)
	}
	return oldValue.Weight, nil
}

// AddWeight adds u to the "weight" field.
func (m *MachineSpecificationMutation) AddWeight(u int) {
	if m.addweight != nil {
		*m.addweight += u
	} else {
		m.addweight = &u
	}
}

// AddedWeight returns the value that was added to the "weight" field in this mutation.
func (m *MachineSpecificationMutation) AddedWeight() (r int, exists bool) {
	v := m.addweight
	if v == nil {
		return
	}
	return *v, true
}

// ResetWeight resets all changes to the "weight" field.
func (m *MachineSpecificationMutation) ResetWeight() {
	m.weight = nil
	m.addweight = nil
}

// SetForks sets the "forks" field.
func (m *MachineSpecificationMutation) SetForks(s string) {
	m.forks = &s
}

// Forks returns the value of the "forks" field in the mutation.
func (m *MachineSpecificationMutation) Forks() (r string, exists bool) {
	v := m.forks
	if v == nil {
		return
	}
	return *v, true
}

// OldForks returns the old "forks" field's value of the MachineSpecification entity.
// If the MachineSpecification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MachineSpecificationMutation) OldForks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldForks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldForks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldForks: %w", err)
	}
	return oldValue.Forks, nil
}

// ResetForks resets all changes to the "forks" field.
func (m *MachineSpecificationMutation) ResetForks() {
	m.forks = nil
}

// SetMastType sets the "mastType" field.
func (m *MachineSpecificationMutation) SetMastType(s string) {
	m.mastType = &s
}

// MastType returns the value of the "mastType" field in the mutation.
func (m *MachineSpecificationMutation) MastType() (r string, exists bool) {
	v := m.mastType
	if v == nil {
		return
	}
	return *v, true
}

// OldMastType returns the old "mastType" field's value of the MachineSpecification entity.
// If the MachineSpecification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MachineSpecificationMutation) OldMastType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMastType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMastType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMastType: %w", err)
	}
	return oldValue.MastType, nil
}

// ClearMastType clears the value of the "mastType" field.
func (m *MachineSpecificationMutation) ClearMastType() {
	m.mastType = nil
	m.clearedFields[machinespecification.FieldMastType] = struct{}{}
}

// MastTypeCleared returns if the "mastType" field was cleared in this mutation.
func (m *MachineSpecificationMutation) MastTypeCleared() bool {
	_, ok := m.clearedFields[machinespecification.FieldMastType]
	return ok
}

// ResetMastType resets all changes to the "mastType" field.
func (m *MachineSpecificationMutation) ResetMastType() {
	m.mastType = nil
	delete(m.clearedFields, machinespecification.FieldMastType)
}

// SetAdditionalAttributes sets the "additionalAttributes" field.
func (m *MachineSpecificationMutation) SetAdditionalAttributes(s string) {
	m.additionalAttributes = &s
}

// AdditionalAttributes returns the value of the "additionalAttributes" field in the mutation.
func (m *MachineSpecificationMutation) AdditionalAttributes() (r string, exists bool) {
	v := m.additionalAttributes
	if v == nil {
		return
	}
	return *v, true
}

// OldAdditionalAttributes returns the old "additionalAttributes" field's value of the MachineSpecification entity.
// If the MachineSpecification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MachineSpecificationMutation) OldAdditionalAttributes(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAdditionalAttributes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAdditionalAttributes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdditionalAttributes: %w", err)
	}
	return oldValue.AdditionalAttributes, nil
}

// ClearAdditionalAttributes clears the value of the "additionalAttributes" field.
func (m *MachineSpecificationMutation) ClearAdditionalAttributes() {
	m.additionalAttributes = nil
	m.clearedFields[machinespecification.FieldAdditionalAttributes] = struct{}{}
}

// AdditionalAttributesCleared returns if the "additionalAttributes" field was cleared in this mutation.
func (m *MachineSpecificationMutation) AdditionalAttributesCleared() bool {
	_, ok := m.clearedFields[machinespecification.FieldAdditionalAttributes]
	return ok
}

// ResetAdditionalAttributes resets all changes to the "additionalAttributes" field.
func (m *MachineSpecificationMutation) ResetAdditionalAttributes() {
	m.additionalAttributes = nil
	delete(m.clearedFields, machinespecification.FieldAdditionalAttributes)
}

// SetEquipment sets the "equipment" field.
func (m *MachineSpecificationMutation) SetEquipment(s string) {
	m.equipment = &s
}

// Equipment returns the value of the "equipment" field in the mutation.
func (m *MachineSpecificationMutation) Equipment() (r string, exists bool) {
	v := m.equipment
	if v == nil {
		return
	}
	return *v, true
}

// OldEquipment returns the old "equipment" field's value of the MachineSpecification entity.
// If the MachineSpecification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MachineSpecificationMutation) OldEquipment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEquipment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEquipment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEquipment: %w", err)
	}
	return oldValue.Equipment, nil
}

// ClearEquipment clears the value of the "equipment" field.
func (m *MachineSpecificationMutation) ClearEquipment() {
	m.equipment = nil
	m.clearedFields[machinespecification.FieldEquipment] = struct{}{}
}

// EquipmentCleared returns if the "equipment" field was cleared in this mutation.
func (m *MachineSpecificationMutation) EquipmentCleared() bool {
	_, ok := m.clearedFields[machinespecification.FieldEquipment]
	return ok
}

// ResetEquipment resets all changes to the "equipment" field.
func (m *MachineSpecificationMutation) ResetEquipment() {
	m.equipment = nil
	delete(m.clearedFields, machinespecification.FieldEquipment)
}

// SetEngine sets the "engine" field.
func (m *MachineSpecificationMutation) SetEngine(s string) {
	m.engine = &s
}

// Engine returns the value of the "engine" field in the mutation.
func (m *MachineSpecificationMutation) Engine() (r string, exists bool) {
	v := m.engine
	if v == nil {
		return
	}
	return *v, true
}

// OldEngine returns the old "engine" field's value of the MachineSpecification entity.
// If the MachineSpecification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MachineSpecificationMutation) OldEngine(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEngine is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEngine requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEngine: %w", err)
	}
	return oldValue.Engine, nil
}

// ResetEngine resets all changes to the "engine" field.
func (m *MachineSpecificationMutation) ResetEngine() {
	m.engine = nil
}

// SetHydraulicControl sets the "hydraulicControl" field.
func (m *MachineSpecificationMutation) SetHydraulicControl(s string) {
	m.hydraulicControl = &s
}

// HydraulicControl returns the value of the "hydraulicControl" field in the mutation.
func (m *MachineSpecificationMutation) HydraulicControl() (r string, exists bool) {
	v := m.hydraulicControl
	if v == nil {
		return
	}
	return *v, true
}

// OldHydraulicControl returns the old "hydraulicControl" field's value of the MachineSpecification entity.
// If the MachineSpecification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MachineSpecificationMutation) OldHydraulicControl(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHydraulicControl is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHydraulicControl requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHydraulicControl: %w", err)
	}
	return oldValue.HydraulicControl, nil
}

// ResetHydraulicControl resets all changes to the "hydraulicControl" field.
func (m *MachineSpecificationMutation) ResetHydraulicControl() {
	m.hydraulicControl = nil
}

// SetDriveControl sets the "driveControl" field.
func (m *MachineSpecificationMutation) SetDriveControl(s string) {
	m.driveControl = &s
}

// DriveControl returns the value of the "driveControl" field in the mutation.
func (m *MachineSpecificationMutation) DriveControl() (r string, exists bool) {
	v := m.driveControl
	if v == nil {
		return
	}
	return *v, true
}

// OldDriveControl returns the old "driveControl" field's value of the MachineSpecification entity.
// If the MachineSpecification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MachineSpecificationMutation) OldDriveControl(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDriveControl is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDriveControl requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDriveControl: %w", err)
	}
	return oldValue.DriveControl, nil
}

// ResetDriveControl resets all changes to the "driveControl" field.
func (m *MachineSpecificationMutation) ResetDriveControl() {
	m.driveControl = nil
}

// SetCabin sets the "cabin" field.
func (m *MachineSpecificationMutation) SetCabin(s string) {
	m.cabin = &s
}

// Cabin returns the value of the "cabin" field in the mutation.
func (m *MachineSpecificationMutation) Cabin() (r string, exists bool) {
	v := m.cabin
	if v == nil {
		return
	}
	return *v, true
}

// OldCabin returns the old "cabin" field's value of the MachineSpecification entity.
// If the MachineSpecification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MachineSpecificationMutation) OldCabin(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCabin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCabin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCabin: %w", err)
	}
	return oldValue.Cabin, nil
}

// ResetCabin resets all changes to the "cabin" field.
func (m *MachineSpecificationMutation) ResetCabin() {
	m.cabin = nil
}

// SetLights sets the "lights" field.
func (m *MachineSpecificationMutation) SetLights(s string) {
	m.lights = &s
}

// Lights returns the value of the "lights" field in the mutation.
func (m *MachineSpecificationMutation) Lights() (r string, exists bool) {
	v := m.lights
	if v == nil {
		return
	}
	return *v, true
}

// OldLights returns the old "lights" field's value of the MachineSpecification entity.
// If the MachineSpecification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MachineSpecificationMutation) OldLights(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLights is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLights requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLights: %w", err)
	}
	return oldValue.Lights, nil
}

// ResetLights resets all changes to the "lights" field.
func (m *MachineSpecificationMutation) ResetLights() {
	m.lights = nil
}

// SetBattery sets the "battery" field.
func (m *MachineSpecificationMutation) SetBattery(s string) {
	m.battery = &s
}

// Battery returns the value of the "battery" field in the mutation.
func (m *MachineSpecificationMutation) Battery() (r string, exists bool) {
	v := m.battery
	if v == nil {
		return
	}
	return *v, true
}

// OldBattery returns the old "battery" field's value of the MachineSpecification entity.
// If the MachineSpecification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MachineSpecificationMutation) OldBattery(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBattery is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBattery requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBattery: %w", err)
	}
	return oldValue.Battery, nil
}

// ClearBattery clears the value of the "battery" field.
func (m *MachineSpecificationMutation) ClearBattery() {
	m.battery = nil
	m.clearedFields[machinespecification.FieldBattery] = struct{}{}
}

// BatteryCleared returns if the "battery" field was cleared in this mutation.
func (m *MachineSpecificationMutation) BatteryCleared() bool {
	_, ok := m.clearedFields[machinespecification.FieldBattery]
	return ok
}

// ResetBattery resets all changes to the "battery" field.
func (m *MachineSpecificationMutation) ResetBattery() {
	m.battery = nil
	delete(m.clearedFields, machinespecification.FieldBattery)
}

// SetMachineID sets the "machine" edge to the Machine entity by id.
func (m *MachineSpecificationMutation) SetMachineID(id int) {
	m.machine = &id
}

// ClearMachine clears the "machine" edge to the Machine entity.
func (m *MachineSpecificationMutation) ClearMachine() {
	m.clearedmachine = true
}

// MachineCleared reports if the "machine" edge to the Machine entity was cleared.
func (m *MachineSpecificationMutation) MachineCleared() bool {
	return m.clearedmachine
}

// MachineID returns the "machine" edge ID in the mutation.
func (m *MachineSpecificationMutation) MachineID() (id int, exists bool) {
	if m.machine != nil {
		return *m.machine, true
	}
	return
}

// MachineIDs returns the "machine" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MachineID instead. It exists only for internal usage by the builders.
func (m *MachineSpecificationMutation) MachineIDs() (ids []int) {
	if id := m.machine; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMachine resets all changes to the "machine" edge.
func (m *MachineSpecificationMutation) ResetMachine() {
	m.machine = nil
	m.clearedmachine = false
}

// Where appends a list predicates to the MachineSpecificationMutation builder.
func (m *MachineSpecificationMutation) Where(ps ...predicate.MachineSpecification) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *MachineSpecificationMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (MachineSpecification).
func (m *MachineSpecificationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MachineSpecificationMutation) Fields() []string {
	fields := make([]string, 0, 19)
	if m.machineNumber != nil {
		fields = append(fields, machinespecification.FieldMachineNumber)
	}
	if m.machineType != nil {
		fields = append(fields, machinespecification.FieldMachineType)
	}
	if m.drive != nil {
		fields = append(fields, machinespecification.FieldDrive)
	}
	if m.loadCapacity != nil {
		fields = append(fields, machinespecification.FieldLoadCapacity)
	}
	if m.year != nil {
		fields = append(fields, machinespecification.FieldYear)
	}
	if m.motorHours != nil {
		fields = append(fields, machinespecification.FieldMotorHours)
	}
	if m.passingHeight != nil {
		fields = append(fields, machinespecification.FieldPassingHeight)
	}
	if m.liftHeight != nil {
		fields = append(fields, machinespecification.FieldLiftHeight)
	}
	if m.weight != nil {
		fields = append(fields, machinespecification.FieldWeight)
	}
	if m.forks != nil {
		fields = append(fields, machinespecification.FieldForks)
	}
	if m.mastType != nil {
		fields = append(fields, machinespecification.FieldMastType)
	}
	if m.additionalAttributes != nil {
		fields = append(fields, machinespecification.FieldAdditionalAttributes)
	}
	if m.equipment != nil {
		fields = append(fields, machinespecification.FieldEquipment)
	}
	if m.engine != nil {
		fields = append(fields, machinespecification.FieldEngine)
	}
	if m.hydraulicControl != nil {
		fields = append(fields, machinespecification.FieldHydraulicControl)
	}
	if m.driveControl != nil {
		fields = append(fields, machinespecification.FieldDriveControl)
	}
	if m.cabin != nil {
		fields = append(fields, machinespecification.FieldCabin)
	}
	if m.lights != nil {
		fields = append(fields, machinespecification.FieldLights)
	}
	if m.battery != nil {
		fields = append(fields, machinespecification.FieldBattery)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MachineSpecificationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case machinespecification.FieldMachineNumber:
		return m.MachineNumber()
	case machinespecification.FieldMachineType:
		return m.MachineType()
	case machinespecification.FieldDrive:
		return m.Drive()
	case machinespecification.FieldLoadCapacity:
		return m.LoadCapacity()
	case machinespecification.FieldYear:
		return m.Year()
	case machinespecification.FieldMotorHours:
		return m.MotorHours()
	case machinespecification.FieldPassingHeight:
		return m.PassingHeight()
	case machinespecification.FieldLiftHeight:
		return m.LiftHeight()
	case machinespecification.FieldWeight:
		return m.Weight()
	case machinespecification.FieldForks:
		return m.Forks()
	case machinespecification.FieldMastType:
		return m.MastType()
	case machinespecification.FieldAdditionalAttributes:
		return m.AdditionalAttributes()
	case machinespecification.FieldEquipment:
		return m.Equipment()
	case machinespecification.FieldEngine:
		return m.Engine()
	case machinespecification.FieldHydraulicControl:
		return m.HydraulicControl()
	case machinespecification.FieldDriveControl:
		return m.DriveControl()
	case machinespecification.FieldCabin:
		return m.Cabin()
	case machinespecification.FieldLights:
		return m.Lights()
	case machinespecification.FieldBattery:
		return m.Battery()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MachineSpecificationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case machinespecification.FieldMachineNumber:
		return m.OldMachineNumber(ctx)
	case machinespecification.FieldMachineType:
		return m.OldMachineType(ctx)
	case machinespecification.FieldDrive:
		return m.OldDrive(ctx)
	case machinespecification.FieldLoadCapacity:
		return m.OldLoadCapacity(ctx)
	case machinespecification.FieldYear:
		return m.OldYear(ctx)
	case machinespecification.FieldMotorHours:
		return m.OldMotorHours(ctx)
	case machinespecification.FieldPassingHeight:
		return m.OldPassingHeight(ctx)
	case machinespecification.FieldLiftHeight:
		return m.OldLiftHeight(ctx)
	case machinespecification.FieldWeight:
		return m.OldWeight(ctx)
	case machinespecification.FieldForks:
		return m.OldForks(ctx)
	case machinespecification.FieldMastType:
		return m.OldMastType(ctx)
	case machinespecification.FieldAdditionalAttributes:
		return m.OldAdditionalAttributes(ctx)
	case machinespecification.FieldEquipment:
		return m.OldEquipment(ctx)
	case machinespecification.FieldEngine:
		return m.OldEngine(ctx)
	case machinespecification.FieldHydraulicControl:
		return m.OldHydraulicControl(ctx)
	case machinespecification.FieldDriveControl:
		return m.OldDriveControl(ctx)
	case machinespecification.FieldCabin:
		return m.OldCabin(ctx)
	case machinespecification.FieldLights:
		return m.OldLights(ctx)
	case machinespecification.FieldBattery:
		return m.OldBattery(ctx)
	}
	return nil, fmt.Errorf("unknown MachineSpecification field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MachineSpecificationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case machinespecification.FieldMachineNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMachineNumber(v)
		return nil
	case machinespecification.FieldMachineType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMachineType(v)
		return nil
	case machinespecification.FieldDrive:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDrive(v)
		return nil
	case machinespecification.FieldLoadCapacity:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLoadCapacity(v)
		return nil
	case machinespecification.FieldYear:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetYear(v)
		return nil
	case machinespecification.FieldMotorHours:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMotorHours(v)
		return nil
	case machinespecification.FieldPassingHeight:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassingHeight(v)
		return nil
	case machinespecification.FieldLiftHeight:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLiftHeight(v)
		return nil
	case machinespecification.FieldWeight:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWeight(v)
		return nil
	case machinespecification.FieldForks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetForks(v)
		return nil
	case machinespecification.FieldMastType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMastType(v)
		return nil
	case machinespecification.FieldAdditionalAttributes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdditionalAttributes(v)
		return nil
	case machinespecification.FieldEquipment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEquipment(v)
		return nil
	case machinespecification.FieldEngine:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEngine(v)
		return nil
	case machinespecification.FieldHydraulicControl:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHydraulicControl(v)
		return nil
	case machinespecification.FieldDriveControl:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDriveControl(v)
		return nil
	case machinespecification.FieldCabin:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCabin(v)
		return nil
	case machinespecification.FieldLights:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLights(v)
		return nil
	case machinespecification.FieldBattery:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBattery(v)
		return nil
	}
	return fmt.Errorf("unknown MachineSpecification field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MachineSpecificationMutation) AddedFields() []string {
	var fields []string
	if m.addmachineNumber != nil {
		fields = append(fields, machinespecification.FieldMachineNumber)
	}
	if m.addloadCapacity != nil {
		fields = append(fields, machinespecification.FieldLoadCapacity)
	}
	if m.addyear != nil {
		fields = append(fields, machinespecification.FieldYear)
	}
	if m.addmotorHours != nil {
		fields = append(fields, machinespecification.FieldMotorHours)
	}
	if m.addpassingHeight != nil {
		fields = append(fields, machinespecification.FieldPassingHeight)
	}
	if m.addliftHeight != nil {
		fields = append(fields, machinespecification.FieldLiftHeight)
	}
	if m.addweight != nil {
		fields = append(fields, machinespecification.FieldWeight)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MachineSpecificationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case machinespecification.FieldMachineNumber:
		return m.AddedMachineNumber()
	case machinespecification.FieldLoadCapacity:
		return m.AddedLoadCapacity()
	case machinespecification.FieldYear:
		return m.AddedYear()
	case machinespecification.FieldMotorHours:
		return m.AddedMotorHours()
	case machinespecification.FieldPassingHeight:
		return m.AddedPassingHeight()
	case machinespecification.FieldLiftHeight:
		return m.AddedLiftHeight()
	case machinespecification.FieldWeight:
		return m.AddedWeight()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MachineSpecificationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case machinespecification.FieldMachineNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMachineNumber(v)
		return nil
	case machinespecification.FieldLoadCapacity:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLoadCapacity(v)
		return nil
	case machinespecification.FieldYear:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddYear(v)
		return nil
	case machinespecification.FieldMotorHours:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMotorHours(v)
		return nil
	case machinespecification.FieldPassingHeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPassingHeight(v)
		return nil
	case machinespecification.FieldLiftHeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLiftHeight(v)
		return nil
	case machinespecification.FieldWeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWeight(v)
		return nil
	}
	return fmt.Errorf("unknown MachineSpecification numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MachineSpecificationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(machinespecification.FieldPassingHeight) {
		fields = append(fields, machinespecification.FieldPassingHeight)
	}
	if m.FieldCleared(machinespecification.FieldMastType) {
		fields = append(fields, machinespecification.FieldMastType)
	}
	if m.FieldCleared(machinespecification.FieldAdditionalAttributes) {
		fields = append(fields, machinespecification.FieldAdditionalAttributes)
	}
	if m.FieldCleared(machinespecification.FieldEquipment) {
		fields = append(fields, machinespecification.FieldEquipment)
	}
	if m.FieldCleared(machinespecification.FieldBattery) {
		fields = append(fields, machinespecification.FieldBattery)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MachineSpecificationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MachineSpecificationMutation) ClearField(name string) error {
	switch name {
	case machinespecification.FieldPassingHeight:
		m.ClearPassingHeight()
		return nil
	case machinespecification.FieldMastType:
		m.ClearMastType()
		return nil
	case machinespecification.FieldAdditionalAttributes:
		m.ClearAdditionalAttributes()
		return nil
	case machinespecification.FieldEquipment:
		m.ClearEquipment()
		return nil
	case machinespecification.FieldBattery:
		m.ClearBattery()
		return nil
	}
	return fmt.Errorf("unknown MachineSpecification nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MachineSpecificationMutation) ResetField(name string) error {
	switch name {
	case machinespecification.FieldMachineNumber:
		m.ResetMachineNumber()
		return nil
	case machinespecification.FieldMachineType:
		m.ResetMachineType()
		return nil
	case machinespecification.FieldDrive:
		m.ResetDrive()
		return nil
	case machinespecification.FieldLoadCapacity:
		m.ResetLoadCapacity()
		return nil
	case machinespecification.FieldYear:
		m.ResetYear()
		return nil
	case machinespecification.FieldMotorHours:
		m.ResetMotorHours()
		return nil
	case machinespecification.FieldPassingHeight:
		m.ResetPassingHeight()
		return nil
	case machinespecification.FieldLiftHeight:
		m.ResetLiftHeight()
		return nil
	case machinespecification.FieldWeight:
		m.ResetWeight()
		return nil
	case machinespecification.FieldForks:
		m.ResetForks()
		return nil
	case machinespecification.FieldMastType:
		m.ResetMastType()
		return nil
	case machinespecification.FieldAdditionalAttributes:
		m.ResetAdditionalAttributes()
		return nil
	case machinespecification.FieldEquipment:
		m.ResetEquipment()
		return nil
	case machinespecification.FieldEngine:
		m.ResetEngine()
		return nil
	case machinespecification.FieldHydraulicControl:
		m.ResetHydraulicControl()
		return nil
	case machinespecification.FieldDriveControl:
		m.ResetDriveControl()
		return nil
	case machinespecification.FieldCabin:
		m.ResetCabin()
		return nil
	case machinespecification.FieldLights:
		m.ResetLights()
		return nil
	case machinespecification.FieldBattery:
		m.ResetBattery()
		return nil
	}
	return fmt.Errorf("unknown MachineSpecification field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MachineSpecificationMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.machine != nil {
		edges = append(edges, machinespecification.EdgeMachine)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MachineSpecificationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case machinespecification.EdgeMachine:
		if id := m.machine; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MachineSpecificationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MachineSpecificationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MachineSpecificationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedmachine {
		edges = append(edges, machinespecification.EdgeMachine)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MachineSpecificationMutation) EdgeCleared(name string) bool {
	switch name {
	case machinespecification.EdgeMachine:
		return m.clearedmachine
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MachineSpecificationMutation) ClearEdge(name string) error {
	switch name {
	case machinespecification.EdgeMachine:
		m.ClearMachine()
		return nil
	}
	return fmt.Errorf("unknown MachineSpecification unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MachineSpecificationMutation) ResetEdge(name string) error {
	switch name {
	case machinespecification.EdgeMachine:
		m.ResetMachine()
		return nil
	}
	return fmt.Errorf("unknown MachineSpecification edge %s", name)
}

// SessionMutation represents an operation that mutates the Session nodes in the graph.
type SessionMutation struct {
	config
	op            Op
	typ           string
	id            *int
	token         *string
	ip            *string
	device        *string
	used          *int
	addused       *int
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	user          *int
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*Session, error)
	predicates    []predicate.Session
}

var _ ent.Mutation = (*SessionMutation)(nil)

// sessionOption allows management of the mutation configuration using functional options.
type sessionOption func(*SessionMutation)

// newSessionMutation creates new mutation for the Session entity.
func newSessionMutation(c config, op Op, opts ...sessionOption) *SessionMutation {
	m := &SessionMutation{
		config:        c,
		op:            op,
		typ:           TypeSession,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSessionID sets the ID field of the mutation.
func withSessionID(id int) sessionOption {
	return func(m *SessionMutation) {
		var (
			err   error
			once  sync.Once
			value *Session
		)
		m.oldValue = func(ctx context.Context) (*Session, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Session.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSession sets the old Session of the mutation.
func withSession(node *Session) sessionOption {
	return func(m *SessionMutation) {
		m.oldValue = func(context.Context) (*Session, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SessionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SessionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SessionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SessionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Session.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetToken sets the "token" field.
func (m *SessionMutation) SetToken(s string) {
	m.token = &s
}

// Token returns the value of the "token" field in the mutation.
func (m *SessionMutation) Token() (r string, exists bool) {
	v := m.token
	if v == nil {
		return
	}
	return *v, true
}

// OldToken returns the old "token" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToken: %w", err)
	}
	return oldValue.Token, nil
}

// ResetToken resets all changes to the "token" field.
func (m *SessionMutation) ResetToken() {
	m.token = nil
}

// SetIP sets the "ip" field.
func (m *SessionMutation) SetIP(s string) {
	m.ip = &s
}

// IP returns the value of the "ip" field in the mutation.
func (m *SessionMutation) IP() (r string, exists bool) {
	v := m.ip
	if v == nil {
		return
	}
	return *v, true
}

// OldIP returns the old "ip" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIP: %w", err)
	}
	return oldValue.IP, nil
}

// ResetIP resets all changes to the "ip" field.
func (m *SessionMutation) ResetIP() {
	m.ip = nil
}

// SetDevice sets the "device" field.
func (m *SessionMutation) SetDevice(s string) {
	m.device = &s
}

// Device returns the value of the "device" field in the mutation.
func (m *SessionMutation) Device() (r string, exists bool) {
	v := m.device
	if v == nil {
		return
	}
	return *v, true
}

// OldDevice returns the old "device" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldDevice(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDevice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDevice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDevice: %w", err)
	}
	return oldValue.Device, nil
}

// ResetDevice resets all changes to the "device" field.
func (m *SessionMutation) ResetDevice() {
	m.device = nil
}

// SetUsed sets the "used" field.
func (m *SessionMutation) SetUsed(i int) {
	m.used = &i
	m.addused = nil
}

// Used returns the value of the "used" field in the mutation.
func (m *SessionMutation) Used() (r int, exists bool) {
	v := m.used
	if v == nil {
		return
	}
	return *v, true
}

// OldUsed returns the old "used" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldUsed(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsed: %w", err)
	}
	return oldValue.Used, nil
}

// AddUsed adds i to the "used" field.
func (m *SessionMutation) AddUsed(i int) {
	if m.addused != nil {
		*m.addused += i
	} else {
		m.addused = &i
	}
}

// AddedUsed returns the value that was added to the "used" field in this mutation.
func (m *SessionMutation) AddedUsed() (r int, exists bool) {
	v := m.addused
	if v == nil {
		return
	}
	return *v, true
}

// ResetUsed resets all changes to the "used" field.
func (m *SessionMutation) ResetUsed() {
	m.used = nil
	m.addused = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *SessionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SessionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SessionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SessionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SessionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SessionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *SessionMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *SessionMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *SessionMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *SessionMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *SessionMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *SessionMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the SessionMutation builder.
func (m *SessionMutation) Where(ps ...predicate.Session) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *SessionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Session).
func (m *SessionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SessionMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.token != nil {
		fields = append(fields, session.FieldToken)
	}
	if m.ip != nil {
		fields = append(fields, session.FieldIP)
	}
	if m.device != nil {
		fields = append(fields, session.FieldDevice)
	}
	if m.used != nil {
		fields = append(fields, session.FieldUsed)
	}
	if m.created_at != nil {
		fields = append(fields, session.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, session.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SessionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case session.FieldToken:
		return m.Token()
	case session.FieldIP:
		return m.IP()
	case session.FieldDevice:
		return m.Device()
	case session.FieldUsed:
		return m.Used()
	case session.FieldCreatedAt:
		return m.CreatedAt()
	case session.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SessionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case session.FieldToken:
		return m.OldToken(ctx)
	case session.FieldIP:
		return m.OldIP(ctx)
	case session.FieldDevice:
		return m.OldDevice(ctx)
	case session.FieldUsed:
		return m.OldUsed(ctx)
	case session.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case session.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Session field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SessionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case session.FieldToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToken(v)
		return nil
	case session.FieldIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIP(v)
		return nil
	case session.FieldDevice:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDevice(v)
		return nil
	case session.FieldUsed:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsed(v)
		return nil
	case session.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case session.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Session field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SessionMutation) AddedFields() []string {
	var fields []string
	if m.addused != nil {
		fields = append(fields, session.FieldUsed)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SessionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case session.FieldUsed:
		return m.AddedUsed()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SessionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case session.FieldUsed:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUsed(v)
		return nil
	}
	return fmt.Errorf("unknown Session numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SessionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SessionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SessionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Session nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SessionMutation) ResetField(name string) error {
	switch name {
	case session.FieldToken:
		m.ResetToken()
		return nil
	case session.FieldIP:
		m.ResetIP()
		return nil
	case session.FieldDevice:
		m.ResetDevice()
		return nil
	case session.FieldUsed:
		m.ResetUsed()
		return nil
	case session.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case session.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Session field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SessionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, session.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SessionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case session.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SessionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SessionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SessionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, session.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SessionMutation) EdgeCleared(name string) bool {
	switch name {
	case session.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SessionMutation) ClearEdge(name string) error {
	switch name {
	case session.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Session unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SessionMutation) ResetEdge(name string) error {
	switch name {
	case session.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Session edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op              Op
	typ             string
	id              *int
	email           *string
	password        *string
	clearedFields   map[string]struct{}
	sessions        map[int]struct{}
	removedsessions map[int]struct{}
	clearedsessions bool
	done            bool
	oldValue        func(context.Context) (*User, error)
	predicates      []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
}

// AddSessionIDs adds the "sessions" edge to the Session entity by ids.
func (m *UserMutation) AddSessionIDs(ids ...int) {
	if m.sessions == nil {
		m.sessions = make(map[int]struct{})
	}
	for i := range ids {
		m.sessions[ids[i]] = struct{}{}
	}
}

// ClearSessions clears the "sessions" edge to the Session entity.
func (m *UserMutation) ClearSessions() {
	m.clearedsessions = true
}

// SessionsCleared reports if the "sessions" edge to the Session entity was cleared.
func (m *UserMutation) SessionsCleared() bool {
	return m.clearedsessions
}

// RemoveSessionIDs removes the "sessions" edge to the Session entity by IDs.
func (m *UserMutation) RemoveSessionIDs(ids ...int) {
	if m.removedsessions == nil {
		m.removedsessions = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.sessions, ids[i])
		m.removedsessions[ids[i]] = struct{}{}
	}
}

// RemovedSessions returns the removed IDs of the "sessions" edge to the Session entity.
func (m *UserMutation) RemovedSessionsIDs() (ids []int) {
	for id := range m.removedsessions {
		ids = append(ids, id)
	}
	return
}

// SessionsIDs returns the "sessions" edge IDs in the mutation.
func (m *UserMutation) SessionsIDs() (ids []int) {
	for id := range m.sessions {
		ids = append(ids, id)
	}
	return
}

// ResetSessions resets all changes to the "sessions" edge.
func (m *UserMutation) ResetSessions() {
	m.sessions = nil
	m.clearedsessions = false
	m.removedsessions = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldEmail:
		return m.Email()
	case user.FieldPassword:
		return m.Password()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.sessions != nil {
		edges = append(edges, user.EdgeSessions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeSessions:
		ids := make([]ent.Value, 0, len(m.sessions))
		for id := range m.sessions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedsessions != nil {
		edges = append(edges, user.EdgeSessions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeSessions:
		ids := make([]ent.Value, 0, len(m.removedsessions))
		for id := range m.removedsessions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedsessions {
		edges = append(edges, user.EdgeSessions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeSessions:
		return m.clearedsessions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeSessions:
		m.ResetSessions()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
