// Code generated by ent, DO NOT EDIT.

package ent

import (
	"api/ent/machine"
	"fmt"
	"strings"

	"entgo.io/ent/dialect/sql"
)

// Machine is the model entity for the Machine schema.
type Machine struct {
	config `json:"-"`
	// ID of the ent.
	ID int `json:"id,omitempty"`
	// Name holds the value of the "name" field.
	Name string `json:"name,omitempty"`
	// Year holds the value of the "year" field.
	Year uint `json:"year,omitempty"`
	// LiftHeight holds the value of the "liftHeight" field.
	LiftHeight uint `json:"liftHeight,omitempty"`
	// MotorHours holds the value of the "motorHours" field.
	MotorHours uint `json:"motorHours,omitempty"`
	// Drive holds the value of the "drive" field.
	Drive string `json:"drive,omitempty"`
	// Weight holds the value of the "weight" field.
	Weight uint `json:"weight,omitempty"`
	// LoadCapacity holds the value of the "loadCapacity" field.
	LoadCapacity uint `json:"loadCapacity,omitempty"`
	// RentPrice holds the value of the "rentPrice" field.
	RentPrice uint `json:"rentPrice,omitempty"`
	// SalePrice holds the value of the "salePrice" field.
	SalePrice uint `json:"salePrice,omitempty"`
	// Description holds the value of the "description" field.
	Description string `json:"description,omitempty"`
	// Hidden holds the value of the "hidden" field.
	Hidden bool `json:"hidden,omitempty"`
	// Deleted holds the value of the "deleted" field.
	Deleted bool `json:"deleted,omitempty"`
	// NumberOfImages holds the value of the "numberOfImages" field.
	NumberOfImages int `json:"numberOfImages,omitempty"`
	// InternalDescription holds the value of the "internalDescription" field.
	InternalDescription string `json:"internalDescription,omitempty"`
	// Edges holds the relations/edges for other nodes in the graph.
	// The values are being populated by the MachineQuery when eager-loading is set.
	Edges MachineEdges `json:"edges"`
}

// MachineEdges holds the relations/edges for other nodes in the graph.
type MachineEdges struct {
	// MachineSpecification holds the value of the machineSpecification edge.
	MachineSpecification []*MachineSpecification `json:"machineSpecification,omitempty"`
	// MachineAccessories holds the value of the machineAccessories edge.
	MachineAccessories []*MachineAccessories `json:"machineAccessories,omitempty"`
	// loadedTypes holds the information for reporting if a
	// type was loaded (or requested) in eager-loading or not.
	loadedTypes [2]bool
}

// MachineSpecificationOrErr returns the MachineSpecification value or an error if the edge
// was not loaded in eager-loading.
func (e MachineEdges) MachineSpecificationOrErr() ([]*MachineSpecification, error) {
	if e.loadedTypes[0] {
		return e.MachineSpecification, nil
	}
	return nil, &NotLoadedError{edge: "machineSpecification"}
}

// MachineAccessoriesOrErr returns the MachineAccessories value or an error if the edge
// was not loaded in eager-loading.
func (e MachineEdges) MachineAccessoriesOrErr() ([]*MachineAccessories, error) {
	if e.loadedTypes[1] {
		return e.MachineAccessories, nil
	}
	return nil, &NotLoadedError{edge: "machineAccessories"}
}

// scanValues returns the types for scanning values from sql.Rows.
func (*Machine) scanValues(columns []string) ([]any, error) {
	values := make([]any, len(columns))
	for i := range columns {
		switch columns[i] {
		case machine.FieldHidden, machine.FieldDeleted:
			values[i] = new(sql.NullBool)
		case machine.FieldID, machine.FieldYear, machine.FieldLiftHeight, machine.FieldMotorHours, machine.FieldWeight, machine.FieldLoadCapacity, machine.FieldRentPrice, machine.FieldSalePrice, machine.FieldNumberOfImages:
			values[i] = new(sql.NullInt64)
		case machine.FieldName, machine.FieldDrive, machine.FieldDescription, machine.FieldInternalDescription:
			values[i] = new(sql.NullString)
		default:
			return nil, fmt.Errorf("unexpected column %q for type Machine", columns[i])
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the Machine fields.
func (m *Machine) assignValues(columns []string, values []any) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case machine.FieldID:
			value, ok := values[i].(*sql.NullInt64)
			if !ok {
				return fmt.Errorf("unexpected type %T for field id", value)
			}
			m.ID = int(value.Int64)
		case machine.FieldName:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field name", values[i])
			} else if value.Valid {
				m.Name = value.String
			}
		case machine.FieldYear:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field year", values[i])
			} else if value.Valid {
				m.Year = uint(value.Int64)
			}
		case machine.FieldLiftHeight:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field liftHeight", values[i])
			} else if value.Valid {
				m.LiftHeight = uint(value.Int64)
			}
		case machine.FieldMotorHours:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field motorHours", values[i])
			} else if value.Valid {
				m.MotorHours = uint(value.Int64)
			}
		case machine.FieldDrive:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field drive", values[i])
			} else if value.Valid {
				m.Drive = value.String
			}
		case machine.FieldWeight:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field weight", values[i])
			} else if value.Valid {
				m.Weight = uint(value.Int64)
			}
		case machine.FieldLoadCapacity:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field loadCapacity", values[i])
			} else if value.Valid {
				m.LoadCapacity = uint(value.Int64)
			}
		case machine.FieldRentPrice:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field rentPrice", values[i])
			} else if value.Valid {
				m.RentPrice = uint(value.Int64)
			}
		case machine.FieldSalePrice:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field salePrice", values[i])
			} else if value.Valid {
				m.SalePrice = uint(value.Int64)
			}
		case machine.FieldDescription:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field description", values[i])
			} else if value.Valid {
				m.Description = value.String
			}
		case machine.FieldHidden:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field hidden", values[i])
			} else if value.Valid {
				m.Hidden = value.Bool
			}
		case machine.FieldDeleted:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field deleted", values[i])
			} else if value.Valid {
				m.Deleted = value.Bool
			}
		case machine.FieldNumberOfImages:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field numberOfImages", values[i])
			} else if value.Valid {
				m.NumberOfImages = int(value.Int64)
			}
		case machine.FieldInternalDescription:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field internalDescription", values[i])
			} else if value.Valid {
				m.InternalDescription = value.String
			}
		}
	}
	return nil
}

// QueryMachineSpecification queries the "machineSpecification" edge of the Machine entity.
func (m *Machine) QueryMachineSpecification() *MachineSpecificationQuery {
	return (&MachineClient{config: m.config}).QueryMachineSpecification(m)
}

// QueryMachineAccessories queries the "machineAccessories" edge of the Machine entity.
func (m *Machine) QueryMachineAccessories() *MachineAccessoriesQuery {
	return (&MachineClient{config: m.config}).QueryMachineAccessories(m)
}

// Update returns a builder for updating this Machine.
// Note that you need to call Machine.Unwrap() before calling this method if this Machine
// was returned from a transaction, and the transaction was committed or rolled back.
func (m *Machine) Update() *MachineUpdateOne {
	return (&MachineClient{config: m.config}).UpdateOne(m)
}

// Unwrap unwraps the Machine entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (m *Machine) Unwrap() *Machine {
	_tx, ok := m.config.driver.(*txDriver)
	if !ok {
		panic("ent: Machine is not a transactional entity")
	}
	m.config.driver = _tx.drv
	return m
}

// String implements the fmt.Stringer.
func (m *Machine) String() string {
	var builder strings.Builder
	builder.WriteString("Machine(")
	builder.WriteString(fmt.Sprintf("id=%v, ", m.ID))
	builder.WriteString("name=")
	builder.WriteString(m.Name)
	builder.WriteString(", ")
	builder.WriteString("year=")
	builder.WriteString(fmt.Sprintf("%v", m.Year))
	builder.WriteString(", ")
	builder.WriteString("liftHeight=")
	builder.WriteString(fmt.Sprintf("%v", m.LiftHeight))
	builder.WriteString(", ")
	builder.WriteString("motorHours=")
	builder.WriteString(fmt.Sprintf("%v", m.MotorHours))
	builder.WriteString(", ")
	builder.WriteString("drive=")
	builder.WriteString(m.Drive)
	builder.WriteString(", ")
	builder.WriteString("weight=")
	builder.WriteString(fmt.Sprintf("%v", m.Weight))
	builder.WriteString(", ")
	builder.WriteString("loadCapacity=")
	builder.WriteString(fmt.Sprintf("%v", m.LoadCapacity))
	builder.WriteString(", ")
	builder.WriteString("rentPrice=")
	builder.WriteString(fmt.Sprintf("%v", m.RentPrice))
	builder.WriteString(", ")
	builder.WriteString("salePrice=")
	builder.WriteString(fmt.Sprintf("%v", m.SalePrice))
	builder.WriteString(", ")
	builder.WriteString("description=")
	builder.WriteString(m.Description)
	builder.WriteString(", ")
	builder.WriteString("hidden=")
	builder.WriteString(fmt.Sprintf("%v", m.Hidden))
	builder.WriteString(", ")
	builder.WriteString("deleted=")
	builder.WriteString(fmt.Sprintf("%v", m.Deleted))
	builder.WriteString(", ")
	builder.WriteString("numberOfImages=")
	builder.WriteString(fmt.Sprintf("%v", m.NumberOfImages))
	builder.WriteString(", ")
	builder.WriteString("internalDescription=")
	builder.WriteString(m.InternalDescription)
	builder.WriteByte(')')
	return builder.String()
}

// Machines is a parsable slice of Machine.
type Machines []*Machine

func (m Machines) config(cfg config) {
	for _i := range m {
		m[_i].config = cfg
	}
}
